[TOC]

# Nginx(엔젠엑스)

- Nginx는 웹 서버이며, 리버스 프록시, 로드 밸런서, 그리고 http 캐시로도 쓰일 수 있는 소프트웨어이다. 요청에 응답하기 위해 이벤트 기반 구조를 채택했고, 현재 웹 서버 분야에서 1등이다.

## 사용 이유

- 웹 서버를 별도로 운영하는 이유? 

  - WAS의 부담을 줄여주기 위해 사용

- Nginx를 사용하는 이유?

  - 빠르다

  | 동시 커넥션 수당 메모리 사용률                               | 동시 커넥션 수가 많아졌을 때 처리하는 초당 요청 수           |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | ![image](https://user-images.githubusercontent.com/87461672/158042025-71b63162-4019-4015-a62d-6d4a0f371f94.png) | ![image-20220313112002934](https://user-images.githubusercontent.com/87461672/158056043-24b9ef35-9a9c-49d1-a63d-195e844efa35.png) |

  - 리버스 프록시로 사용 가능 (Reverse Proxy)
    - 인터넷과 백엔드 그 사이에 있는 서버, 로드 밸런싱(요청을 여러 서버로 분산하는 작업을 수행)과 캐싱( 한번 서버로 부터 받은 응답을 스스로 보관하고 클라이언트에게 전달)을 해줄 수 있다. 또, 보안 효과도 있음.

  - SSL 지원
    - HTTPS의 인증서를 제공해 줄 수 있음.

  - 웹페이지 접근 인증
    - 로그인 정보가 올바른 정보인지 WAS 에서 검증할 수 있는데 WAS에서 하지 않고 Nginx에서 해줄 수 있음.

  - 압축
    - 클라이언트가 보내는 요청이 Text일 경우에 gzip을 사용해서 데이터를 압축해서 전달 해 줄 수 있음.

  - 비동기 처리

## 아파치 서버

- 1995년 유닉스 기반으로 만들어진 최초의 웹서버, NCSA HTTPd 가 있다. 버그가 굉장히 많아서 불편해서 이런 버그를 수정하면서 구조를 변경하고 기능을 추가해서 만든 것이 아파치 서버이다.

### 구조

![image](https://user-images.githubusercontent.com/87461672/158042462-f84c2af1-b1af-492a-ad51-f2d9b4be30ff.png)

- 아파치는 요청이 들어오면 커넥션을 형성하기 위해 프로세스를 생성한다. 그래서 새로운 클라이언트의 요청이 들어올때 마다 새로운 프로세스를 만든다.

- 그런데 프로세스를 만드는 것이 시간이 걸리는 작업이다 보니 요청이 들어오기전에 미리 프로세스를 만들어 놓는 PREFORK 방식을 사용한다. 그래서 새로운 클라이언트로부터 요청이 들어오면 미리 만들어 놓은 프로세스를 가져다 사용한다.

- 만약 만들어 놓은 프로세스가 모두 할당되었다면 추가로 프로세스를 만들었다.

### 장점

![image-20220311225335349](../AppData/Roaming/Typora/typora-user-images/image-20220311225335349.png)

- 이런 구조는 개발하기 쉽다는 장점이 있다. 덕분에 개발자들은 다양한 모듈을 만들어서 서버에 빠르게 기능을 추가할 수 있다. 이런식으로 아파치 서버는 동적 컨텐츠를 처리할 수도 있게 됐다.

- 그리고 확장성이 좋다는 장점 덕분에 요청을 받고 응답을 처리하는 과정을 하나의 서버에서 해결하기 좋다.

### 문제 발생 

#### 동시에 연결된 커넥션 수 != 초당 요청 처리 수

|                   동시에 연결된 커넥션 수                    |                      초당 요청 처리 수                       |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image-20220313114923667](https://user-images.githubusercontent.com/87461672/158056191-c68e5451-bfff-4ce2-b0da-a6c335a724e1.png) | ![image](https://user-images.githubusercontent.com/87461672/158042796-9904566c-e01d-4187-a530-df371c6572b4.png) |
| 요청을 처리하기 위해 서버가 한 시점에 얼마나 많은 클라이언트와 커넥션을 형성하고 있는지를 나타냄. |  서버가 얼마나 빨리 요청을 처리할 수 있는지를 나타내는 지표  |

- 각 요청마다 매번 커넥션을 만들기엔 비효율적이고 속도도 느림. 그래서 요청을 보낼 때, 이미 만들어진 커넥션이 있다면 재활용한다.
  - http 프로토콜을 보면 header의 종류 중에 'keep-Alive'헤더가 있는데 이 헤더에 적힌 시간만큼 클라이언트와 서버는 한번 형성한 커넥션을 계속 유지한다.

![image](https://user-images.githubusercontent.com/87461672/158042960-72429ffa-67ac-4c49-83d9-3dd7ace2dab7.png)

- 1999년 , 인터넷 트래픽이 계속해서 증가하는 상황.

|            서버가 처리해야 할 요청 양이 감당 가능            | 서버에 동시에 연결된 커넥션이 많아졌을 때, 더 이상 커넥션을 형성하지 못함. |
| :----------------------------------------------------------: | ------------------------------------------------------------ |
| ![image-20220311231002252](https://user-images.githubusercontent.com/87461672/158042672-4eee2278-61ee-4a0e-a673-16dc42752b32.png) | ![image-20220311231132793](https://user-images.githubusercontent.com/87461672/158042678-f3713c0e-3eff-4ce5-8960-a7b1c46854ab.png) |

- C10K - connection 10000 problem
  - 동시 커넥션 수가 10000단위로 넘어가는 순간, 서버는 더이상 커넥션을 형성하지 못하는 상황에 놓인다.  - 서버의 문제!

![image](https://user-images.githubusercontent.com/87461672/158043385-eb676c02-c18f-4d3f-90d2-e4b61a010414.png)

- 아파치 서버는 구조상 커넥션이 형성 될 때마다 프로세스를 할당하기 때문에 동시에 처리하고 있는 커넥션이 많아지면 그만큼 형성된 프로세스가 많다는 거고 이는 곧 메모리 부족 현상으로 이어진다. 

- 아파치 서버의 여러가지 기능을 쉽게 추가할 수 있는 특징은 프로세스가 차지하는 리소스의 양을 늘렸다.

- 그리고 많은 커넥션에서 요청이 들어오기 시작하면 CPU 코어는 계속해서 프로세스를 바꿔가며 일을 해야했다. 컨텍스트 스위칭을 굉장히 많이 한다는 것인데,  그만큼 CPU가 감당해야할 일이 지나치게 많았다. 

- 쉽게 말해서 **수많은 동시 커넥션을 감당하기엔 아파치 서버가 부적합**하다. 
  - 이런 구조적인 한계를 극복하기위해 다양한 시도를 하고 있다. 성능 개선이 지금까지도 이루어지고 있고 새롭게 만들어지는 서버는 다른 구조를 채택하기도한다.

## Nginx(엔진엑스)

- 2004년에 아파치 서버를 보안하기위해 Nginx가 나옴. 아파치 서버와 함께 사용하기 위해 만들어졌다. 

![image](https://user-images.githubusercontent.com/87461672/158043393-da1179e2-acb5-4dba-a9aa-bb14558fbc5e.png)

- 아파치 서버 앞단에 nginx를 둠. 구조적으로 동시 커넥션을 감당하지 못하는 아파치 서버의 부하를 nginx를 이용해 크게 줄일 수 있다.  
- nginx는 그자체로 웹서버여서 정적 파일에 대한 요청을 스스로 처리할 수 있다.  웹 서버 역할의 엔진엑스는 클라이언트로부터 동적 파일 요청을 받았을 때만 뒤에 있는 서버와 커넥션을 형성한다. 
  - 아파치 서버의 리소스를 커넥션 유지에 쓰지 않고, 개발자가 원하는 로직 처리에 쓰도록 도와주는 것. 

### 구조

nginx구조는 master process - 설정 파일을 읽고, 설정에 맞게 워커 프로세스를 생성하는 프로세스다.

워커 프로세스가 실제로 일을 하는 녀석. 워커  프로세스가 만들어 질떄 각자 지정된 listen 소켓을 배정받는다.  그리고 그 소켓에 새로운 클라이언트로부터 요청이 들어오면 커넥션을 형성하고 그 요청을 처리한다. 그러고 나면 그 커넥션은 정해진 keep alive 시간만큼 유지된다. 그치만 커넥션이 형성 되었다고 해서  이 워커 페이스가 해당커넥션 하나만 한정적으로 담당하진 않는다. 형성된 커넥션에 아무런 요청이 없으면 새로운 커넥션을 형성하거나 이미 만들어진 다른 커넥션으로부터 들어온 요청을 처리한다.  nginx에서는 이런 커넥션 형성, 커넥션 제거,  그리고 새로운 요청을 처리하는 것을 이벤트라고 부른다.

![image-20220311233039325](https://user-images.githubusercontent.com/87461672/158043417-76b3cc28-cea2-4ccc-b594-610c6fe161f9.png)

- master process 가 Nginx 의 설정파일을 읽고 그 설정에 맞게 작업을 처리하는 worker process 를 생성한다. 
- worker process 가 만들어질 때, 지정된 listen socket 을 배정받는다. 
- 그 소켓에 요청이 들어오면 커넥션을 형성한다.
- 하나의 worker process 가 여러 개의 커넥션으로부터 요청을 처리할 수 있다.

![image-20220311233157493](https://user-images.githubusercontent.com/87461672/158043516-9e74953a-11a7-45b2-bf8a-583dcc5b4f53.png)

- Nginx 에서 커넥션 형성, 제거, 요청을 처리하는 것을 이벤트라고 부르고, OS 커널이 이 이벤트를 큐(Queue) 형식으로 worker process 에 전달해준다. 이 이벤트들은 '비동기'방식으로 처리를 기다린다.  worker process 는 하나의 스레드로 이 이벤트를 처리해간다.

  ![image](https://user-images.githubusercontent.com/87461672/158043549-3051f4eb-3778-44ef-85c1-d899b7c16e47.png)

- 하나의 이벤트가 시간이 오래 소요된다면 이런 작업들을 별도로 관리해서 처리하는 Thread Pool 에 위임한다.

![image-20220311234508941](https://user-images.githubusercontent.com/87461672/158043578-a99c02c0-a2a8-4091-b671-3ad41dbe6787.png)

- worker process 는 CPU 의 코어 개수만큼 생성한다. CPU 의 코어가 담당하는 프로세스를 바꾸는 일(컨텍스트 스위칭)이 굉장히 적어지기 때문에 낭비되는 리소스를 줄일 수 있다.

- 이게 바로 Nginx가 채택한 event-driven model, 즉 이벤트 기반 구조이고, 아파치 서버와 가장 큰 차이점이다.

### 단점

- 개발자가 기능 추가를 시도했다가 돌아가고 있는 워커 프로세스를 종료하게 되는 상황이 생길 수 있다. 그러면 해당 워커 프로세스가 관리하고 있던 커넥션과  관련된 요청을 더이상 처리할 수 없게 되는 문제가 발생한다.  그래서 nginx는 개발자가 직접 모듈을 만들기가 까다롭다. 

### 장점

- 수 많은 동시 커넥션을 빠르게 처리하는데,  프로세스를 적게 만들다 보니 가볍기 까지 했다. 

![image-20220312000716022](https://user-images.githubusercontent.com/87461672/158043650-dd4261c7-bf77-43c8-9cca-8a7f85fbd394.png)

- 프로세스를 적게만드는 이 구조는 동적 설정 변경 가능
  - Nginx 는 동적 설정 변경을 지원하는데, Nginx 가 설정을 변경하면 master process 는 해당 설정에 맞는 worker process 를 새로 생성하고 기존의 worker process 에 더 이상의 이벤트를 할당받지 않도록 한다. 기존 worker process 의 이벤트가 전부 처리되면 해당 프로세스를 종료하고 새로운 worker process 로 기능을 수행한다.

![image](https://user-images.githubusercontent.com/87461672/158043736-571a8ba3-5c9f-4df8-8c49-b81b2fb22daa.png)

- 동적 설정 변경의 대표적인 예는 WAS 증설에 있다. Nginx 가 로드 밸런서의 역할을 수행하면서 WAS 를 증설할 때 설정을 변경해야하는데, 위와 같은 방식으로 설정 변경을 처리하면 초당 수십번을 해도 문제없이 이벤트를 처리할 수 있다.



## 아파치 서버 vs Nginx

- 아파치도 MPM이라는 모듈을 추가해서 성능을 개선했다.  Multi processing modules, 아파치 서버를 어떤 방식으로 운영할지 선택할 수 있다. 안정성이나 하위호환이 필요하다면 기존의 prefork 방식을 사용하고, 성능 향상을 원한다면, 워커라고 불리는 스레드를 만들어서 워커가 요청을 처리하도록 했다. 

- 아파치는 서버 자체게 다양한 OS에서 안정적이란 장점이 있다.  Nginx는 윈도우에서 제대로 된 성능을 발휘하지 못한다. 모듈의 종류는 아파치 서버가 nginx 보다 훨씬 많다. 





## 출처

[[10분 테코톡\] 🤫 피케이의 Nginx - YouTube](https://www.youtube.com/watch?v=6FAwAXXj5N0)

[[Nginx\] (1/2) 도대체 뭐길래 카카오, 네이버에서 사용할까 - YouTube](https://www.youtube.com/watch?v=ZJpT-Wa-pZ8)