[TOC]

# Chapter 03. 코드에서 나는 악취

> 리팩터링하면 해결할 수 있는 문제의 징후

- **이 장의 내용**과 **부록 B**를 참고해서 코드가 풍기는 냄새(악취)를 파악하고, 해법으로 제시한 리팩터링 기법을 **6~12장**에서 찾기

<br>

### 기이한 이름 (Mysterious Name)

> 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경 써야 함

- [**6.5 함수 선언 바꾸기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#65-함수-선언-바꾸기), [**6.7 변수 이름 바꾸기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#67-변수-이름-바꾸기), [**9.2 필드 이름 바꾸기**]() 와 같은 리팩터링이 많이 사용됨
  - 마땅한 이름이 떠오르지 않는다면 <u>설계에 더 근본적인 문제</u>가 숨어 있을 가능성이 높음

<br>

### 중복 코드 (Duplicated Code)

> 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생김

- 한 클래스에 딸린 두 메서드가 **똑같은 표현식을 사용**하는 경우 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 로 양쪽 모두 추출된 메서드를 호출
- 코드가 비슷하긴 한데 완전히 똑같지 않다면, [**8.6 문장 슬라이드하기**]() 로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용
- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 [**12.1 메서드 올리기**]() 를 적용해 부모로 옮김

<br>

### 긴 함수 (Long Function)

> **간접 호출(indirection)** 의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것

- **'무엇을 하는지'**를 코드가 잘 설명해주지 못할수록 함수로 만들고, 최대한 <u>본문 코드를 볼 이유가 없도록 해야함</u>
- 함수를 짧게 만드는 작업의 99%는 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 가 차지함 (추출된 함수에 **매개변수가 많은 경우** 아래를 시행)
  - [**7.4 임시 변수를 질의 함수로 바꾸기**]() 로 <u>임시 변수의 수</u> 줄이기
  - [**6.8 매개변수 객체 만들기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#68-매개변수-객체-만들기) 와 [**11.4 객체 통째로 넘기기**]() 로 <u>매개변수의 수</u> 줄이기
  - 위의 방법을 적용해도 너무 많다면 더 큰 수술인 [**11.9 함수를 명령으로 바꾸기**]() 고려
- **주석** : 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓기
- **조건문** : 단순 조건문은 [**10.1 조건문 분해하기**](), 거대한 switch문을 구성하는 case문마다 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 적용
  - 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 [**10.4 조건부 로직을 다형성으로 바꾸기**]() 적용
- **반복문** : 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 [**8.7 반복문 쪼개기**]() 를 적용해서 작업을 분리

<br>

### 긴 매개변수 목록 (Long Parameter List)

> 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많음

- 다른 매개변수에서 값을 얻어올 수 있는 매개변수는 [**11.5 매개변수를 질의 함수로 바꾸기**]() 로 제거
- 사용 중인 데이터 구조에서 값들을 뽑아 <u>각각을 별개의 매개변수로 전달</u>하는 코드는 [**11.4 객체 통째로 넘기기**]() 로 **원본 데이터 구조**를 전달
- 항상 함께 전달되는 매개변수들은 [**6.8 매개변수 객체 만들기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#68-매개변수-객체-만들기) 로 하나로 묶기
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 [**11.3 플래그 인수 제거하기**]() 로 없애기
- 여러 개의 함수가 <u>특정 매개변수들의 값을 공통으로 사용</u>할 때 [**6.9 여러 함수를 클래스로 묶기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#69-여러-함수를-클래스로-묶기) 로 공통 값들을 클래스의 필드로 정의

<br>

### 전역 데이터 (Global Data)

> 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제

- 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생
  - 대표적인 리팩터링은 [**6.6 변수 캡슐화하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#66-변수-캡슐화하기) 로 <u>다른 코드에서 오염시킬 가능성이 있는 데이터</u>를 발견하면 이 기법을 가장 먼저 적용

<br>

### 가변 데이터 (Mutable Data)

> 데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있으므로, 불변성을 지키는 것이 중요

- [**6.6 변수 캡슐화하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#66-변수-캡슐화하기) 로 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록하여 어떻게 수정되는지 감시
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 [**9.1 변수 쪼개기**]() 로 용도별로 독립 변수에 저장하여 문제 여지를 없앰
  - 갱신 로직은 [**8.6 문장 슬라이드하기**]() 와 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 로 다른 코드와 떨어뜨려 놓기
  - API 를 만들 때는 [**11.1 질의 함수와 변경 함수 분리하기**]() 로 꼭 필요한 경우가 아니면 부작용이 있는 코드의 호출 방지
  - 가능한 한 [**11.7 세터 제거하기**]() 도 적용하여, 세터를 호출하는 클라이언트 찾기
- 값을 다른 곳에서 설정할 수 있는 가변 데이터는 [**9.3 파생 변수를 질의 함수로 바꾸기**]() 를 적용
- [**6.9 여러 함수를 클래스로 묶기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#69-여러-함수를-클래스로-묶기) 나 [**6.10 여러 함수를 변환 함수로 묶기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#610-여러-함수를-변환-함수로-묶기) 로 변수를 갱신하는 코드들의 유효범위를 제한
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면 [**9.4 참조를 값으로 바꾸기**]() 로 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체

<br>

### 뒤엉킨 변경 (Divergent Change)

> 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생
>
> **단일 책임 원칙 (SRP, Single Responsibility Principle)** 이 제대로 지켜지지 않을 때

- [**6.11 단계 쪼개기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#611-단계-쪼개기) 로 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리
- 전체 처리 과정 곳곳에서 <u>각기 다른 맥락의 함수를 호출하는 빈도</u>가 높다면, [**8.1 함수 옮기기**]() 로 적당한 모듈을 만들어 관련 함수들을 모으기
  - 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 부터 수행
  - 모듈이 클래스라면 [**7.5 클래스 추출하기**]() 가 맥락별 분리 방법을 잘 안내해줄 것

<br>

### 산탄총 수술 (Shotgun Surgery)

> 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생

![image](https://github.com/CS-yorisa/CS-COOK-BOOK/assets/87461594/ae67a953-47ab-430a-af13-62889f67ba63)

- 함께 변경되는 대상들을 [**8.1 함수 옮기기**]() 와 [**8.2 필드 옮기기**]() 로 모두 한 모듈에 묶기
- 비슷한 데이터를 다루는 함수가 많다면 [**6.9 여러 함수를 클래스로 묶기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#69-여러-함수를-클래스로-묶기) 적용
- 데이터 구조를 변환하거나 보강하는 함수들에는 [**6.10 여러 함수를 변환 함수로 묶기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#610-여러-함수를-변환-함수로-묶기) 적용
- 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 [**6.11 단계 쪼개기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#611-단계-쪼개기) 를 적용
- 어설프게 분리된 로직을 [**6.2 함수 인라인하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#62-함수-인라인하기) 나 [**7.6 클래스 인라인하기**]() 같은 인라인 리팩터링으로 합치는 것도 좋은 방법

<br>

### 기능 편애 (Feature Envy)

> 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 많을 때

- 해당하는 부분을 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 로 독립 함수로 빼내고  [**8.1 함수 옮기기**]() 로 데이터 근처(모듈)로 옮기기
  - 함수가 사용하는 모듈이 다양하다면 <u>가장 많은 데이터를 포함한 모듈</u>로 옮기기 (함수를 여러 조각으로 나누어 옮겨도 좋음)

<br>

### 데이터 뭉치 (Data Clumps)

> **데이터 항목 서너 개**가 클래스 두어 개의 필드나 여러 메서드의 시그니처에서 함께 발견되는 경우

- 필드 형태의 데이터 뭉치를 찾아서 [**7.5 클래스 추출하기**]() 로 하나의 객체로 묶기

  - 메서드 시그니처에 있는 데이터 뭉치는 [**6.8 매개변수 객체 만들기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#68-매개변수-객체-만들기) 나 [**11.4 객체 통째로 넘기기**]() 로 매개변수 수를 줄이기

  > 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도 괜찮음

<br>

### 기본형 집착 (Primitive Obsession)

> 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기 꺼려하는 부분에서 발생

- [**7.3 기본형을 객체로 바꾸기**]() 를 적용하여 의미 있는 자료형을 형성
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 [**12.6 타입 코드를 서브클래스로 바꾸기**]() 와 [**10.4 조건부 로직을 다형성으로 바꾸기**]() 를 차례로 적용
- 자주 몰려다니는 기본형 그룹(데이터 뭉치)은 [**7.5 클래스 추출하기**]() 와 [**6.8 매개변수 객체 만들기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#68-매개변수-객체-만들기) 적용

<br>

### 반복되는 switch문 (Repeated Switches)

> 중복된 switch문은 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 함

- [**10.4 조건부 로직을 다형성으로 바꾸기**]() 를 적용하여 중복된 switch문 제거

<br>

### 반복문 (Loops)

> 프로그래밍 언어가 등장할 때 핵심 프로그래밍 요소였던 반복문은 이제 시대에 걸맞지 않은 존재가 되었음

- [**8.8 반복문을 파이프라인으로 바꾸기**]() 를 적용해 반복문 제거

<br>

### 성의 없는 요소 (Lazy Element)

> 필요가 없거나 역할이 줄어든 프로그램 요소는 제거하는게 좋음

- [**6.2 함수 인라인하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#62-함수-인라인하기) 나 [**7.6 클래스 인라인하기**]() 로 요소 제거
  - 상속을 사용했다면 [**12.9 계층 합치기**]() 를 적용

<br>

### 추측성 일반화 (Speculative Generality)

> 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 발생

- 하는 일이 거의 없는 추상 클래스는 [**12.9 계층 합치기**]() 로 제거
- 쓸데없이 위임하는 코드는 [**6.2 함수 인라인하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#62-함수-인라인하기) 나 [**7.6 클래스 인라인하기**]() 로 삭제
- 본문에서 사용되지 않는 매개변수는 [**6.5 함수 선언 바꾸기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#65-함수-선언-바꾸기) 로 제거 (나중에 다른 버전을 위해 추가한 매개변수도 이 기법으로 제거)
- 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스의 **추측성 일반화**는 [**8.9 죽은 코드 제거하기**]() 로 제거

<br>

### 임시 필드 (Temporary Field)

> 특정 상황에서만 값이 설정되는 임시 필드를 갖도록 작성하면 코드를 이해하기 어려움

- 이러한 임시 필드는 [**7.5 클래스 추출하기**]() 로 올바른 위치로 이동
  - 그런 다음 [**8.1 함수 옮기기**]() 로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣기
- 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직은 [**10.5 특이 케이스 추가하기**]() 로 대안 클래스를 만들어서 제거

<br>

### 메시지 체인 (Message Chains)

> 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 형태 (다른 객체를 요청하는 작업이 반복)

- [**7.7 위임 숨기기**]() 로 메시지 체인을 해결 (메시지 체인의 다양한 연결점에 적용할 수 있음)
- [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 로 결과 객체를 사용하는 코드 일부를 따로 빼내서 [**8.1 함수 옮기기**]() 로 체인을 숨기는 방식도 고려

<br>

### 중개자 (Middle Man)

> 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 경우

- [**7.8 중개자 제거하기**]() 를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하기
- 위임 메서드를 제거한 후 남는 일이 거의 없다면 [**6.2 함수 인라인하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#62-함수-인라인하기) 를 통해 호출하는 쪽으로 인라인하기

<br>

### 내부자 거래 (Insider Trading)

> 모듈 사이의 데이터 거래의 양을 최소로 줄이고 모두 투명하게 처리해야 함

- 데이터를 주고받는 모듈들은 [**8.1 함수 옮기기**]() 와 [**8.2 필드 옮기기**]() 기법으로 떼어놓아 사적으로 처리하는 부분을 줄이기
- 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 **제3의 모듈**을 새로 만들거나 [**7.7 위임 숨기기**]() 로 다른 모듈이 <u>중간자 역할</u>을 하게 만듬
- [**12.10 서브클래스를 위임으로 바꾸기**]() 나 [**12.11 슈퍼클래스를 위임으로 바꾸기**]() 로 상속 구조에서 부모와 자식을 분리

<br>

### 거대한 클래스 (Large Class)

> 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어나고, 이에따라 중복 코드가 생기기 쉬워짐

- [**7.5 클래스 추출하기**]() 로 필드들 일부를 따로 묶기 (같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택)
  - 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면 [**12.8 슈퍼클래스 추출하기**]() 나 [**12.6 타입 코드를 서브클래스로 바꾸기**]() 적용
- 클라이언트가 거대 클래스의 **특정 기능 그룹만 주로 사용**하는지 살피고, 개별 클래스로 추출될 후보로 선정하여 위의 방법들을 적용

<br>

### 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interface)

> 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것

- [**6.5 함수 선언 바꾸기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#65-함수-선언-바꾸기) 로 메서드 시그니처를 일치시키고 교체하기
- [**8.1 함수 옮기기**]() 를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣기
- 대안 클래스들 사이에 중복 코드가 생기면 [**12.8 슈퍼클래스 추출하기**]() 적용 고려

<br>

### 데이터 클래스 (Data Class)

> 데이터 필드와 게터/세터 메서드로만 구성된 클래스

- 이런 클래스에 public 필드가 있다면 [**7.1 레코드 캡슐화하기**]() 로 숨기기
- 변경하면 안 되는 필드는 [**11.7 세터 제거하기**]() 로 접근을 원천 봉쇄
- 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아서 [**8.1 함수 옮기기**]() 로 그 메서드를 데이터 클래스로 옮기기
  - 메서드를 통째로 옮기기 어렵다면 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 로 옮길 수 있는 부분만 별도 메서드로 뽑아내기
- 필요한 동작이 엉뚱한 곳에 정의된 데이터 클래스의 경우 <u>클라이언트 코드를 데이터 클래스로 옮기기</u>만 해도 되는 경우가 있음
  - [**6.11 단계 쪼개기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#611-단계-쪼개기) 의 결과로 나온 중간 데이터 구조처럼 **'불변 데이터'** 의 경우 캡슐화하 필요 없고, 필드 자체를 공개해도 됨

<br>

### 상속 포기 (Refused Bequest)

> 부모의 메서드와 데이터 중 관심 있는 몇 개를 제외하고는 상속을 원하지 않는 경우

- 상속을 포기할 시 혼란과 문제가 생기는 경우 → [**12.4 메서드 내리기**]() 와 [**12.5 필드 내리기**]() 를 활용하여 새로운 서브클래스 활용
- 서브클래스가 부모의 동작은 필요로하지만 <u>인터페이스는 따르고 싶지 않을 경우</u>
  - [**12.10 서브클래스를 위임으로 바꾸기**]() 나 [**12.11 슈퍼클래스를 위임으로 바꾸기**]() 를 활용하여 **상속 메커니즘**에서 벗어나기

<br>

### 주석 (Comments)

> 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 많음
>
> "주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해보기"

- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 [**6.1 함수 추출하기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#61-함수-추출하기) 적용
  - 이미 추출되어 있는 함수임에도 설명이 필요하다면 [**6.5 함수 선언 바꾸기**](https://github.com/CS-yorisa/CS-COOK-BOOK/blob/main/books/리팩터링%202판/Chapter%2006.md#65-함수-선언-바꾸기) 로 함수 이름을 변경
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 [**10.6 어서션 추가하기**]() 적용