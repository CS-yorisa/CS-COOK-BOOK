[TOC]

# Chapter 02. 리팩터링 원칙

> **리팩터링** : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- 리팩터링하기 전과 후의 코드의 동작이 **사용자 관점**에서는 달라지지 않아야 함
- <u>리팩터링 과정에서 발견된 버그</u>는 리팩터링 후에도 그대로 남아 있어야 함
- **'기능 추가'** 와 **'리팩터링'** 은 번갈아가며 이루어질 수 있지만, 확실히 작업을 구분해서 진행하는게 좋음

<br>

## 리팩터링하는 이유

- **소프트웨어 설계가 좋아짐**

  - 내부 설계(아키텍처)의 이해도를 높이고, 견고하게 만들 수 있음
  - 중복을 제거하면서 코드의 길이를 줄여 소프트웨어를 수정하는 데 드는 비용을 줄일 수 있음

- **소프트웨어를 이해하기 쉬워짐**

  - 기억할 필요가 있는 것들을 최대한 코드에 담아서, 나중에 코드를 이해하기 쉽게 만들 수 있음

- **버그를 쉽게 찾을 수 있음**

- **프로그래밍 속도를 높일 수 있음**

  - 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있음

  ![image](https://github.com/CS-yorisa/CS-COOK-BOOK/assets/87461594/f0810164-8ca7-4107-8c93-9a21728b3627)

<br>

## 리팩터링이 필요한 시점

### 3의 법칙 (by. 돈 로버츠)

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일을 <u>세 번째</u> 하게 되면 리팩터링 한다.

> 스트라이크 세 번이면 리팩터링하라 **(삼진 리팩터링)**

#### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

- 코드베이스에 <u>기능을 새로 추가하기 직전</u>
  - 현재 코드의 구조를 변경하여 다른 작업을 하기 쉬워질 만한 부분 찾기
- 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수 → [**11.2 함수 배개변수화하기**]() 적용으로 함수에 필요한 매개변수를 지정해서 호출

#### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

- 코드가 하는 일을 파악하고, <u>머리로 이해한 것을 코드에 반영</u>하기
  - 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링

#### 쓰레기 줍기 리팩터링

- 간단히 수정할 수 있는 것은 즉시 고치고, <u>시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리</u>
  - 작업을 잘게 나누어 몇 달에 걸쳐 진행하더라도, **코드가 깨지지 않는 것**이 중요

#### 계획된 리팩터링과 수시로 하는 리팩터링

- **계획된 리팩터링** : 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링 등 기회가 될때 리팩터링 일정을 잡고 진행
- **수시로 하는 리팩터링** : 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니기에, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 진행

> 기능 추가와 리팩터링을 분리한다고 무조건 좋은 것이 아님을 명심하고, **팀에 적합한 방식**을 실험을 통해 찾아내야 함

#### 오래 걸리는 리팩터링

- 어려운 리팩토링 과제도 팀 전체가 매달리기보다, 몇 주에 걸쳐 <u>조금씩 해결해가는 편</u>이 효과적일 때가 많음
  - 누구든 리팩터링해야할 코드와 관련한 작업을 하게 될 때마다 조금씩 개선하기 (단, 코드를 깨트리지 않는다는 가정하에)

#### 코드 리뷰에 리팩터링 활용하기

- 코드 리뷰를 통해 서로의 아이디어를 공유하고, <u>리팩터링까지 반영하여 더욱 넓게 개선하는 방안</u>도 도출할 수 있음
  - 코드 리뷰에 리팩터링을 접목하는 방식은 Pull Request Model 보다 **코드 작성자가 함께 참석하는 방식**이 좋음 (나란히 앉아서 코드 훑어보기)

#### 리팩터링하지 말아야 할 때

- 외부 API 처럼 호출하는 코드는 지저분해도 그냥 두고, <u>내부 동작을 이해해야 하는 시점</u>에 리팩터링을 진행
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않음 → **판단에 많은 경험이 필요한 과정**

<br>

## 리팩터링 시 고려할 문제

#### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것

- 코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있음
  - 리팩터링을 도덕적인 이유로 정당화하면 안되고, 어디까지가 <u>경제적인 효과</u>에 있음을 명심
  - 추가하려는 기능이 아주 작아서 리팩토링이 고민되는 경우, 경험을 통해서 잘 결정하는 것도 중요

#### 코드 소유권

- 함수를 호출하는 코드의 소유자가 다른 팀이라 권한이 없거나, 고객에게 API 로 제공되는 것이라 리팩토링이 불가할 수 있음
  - 코드 소유권을 작은 단위로 나누기보다, <u>코드의 소유권을 팀에 두는 것</u>이 좋을 수 있음
  - 다른 팀 사람이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는 **오픈소스 개발 모델** → 대규모 시스템 개발 시 어울리는 절충안

#### 브랜치

- 브랜치 방식의 경우 **작업하는 기간이 길어질수록** <u>마스터를 개인 브랜치로 수시로 리베이스하거나 머지해야 함</u>

  - 오랜시간 작업한 브랜치를 마스터에 머지하는 경우 문제가 쉽게 발생할 수 있음

  - 브랜치를 활용하는 경우 **CI** 를 적용하여 머지의 복잡도를 줄일 필요가 있음 (마스터와 통합하는 작업을 매일 진행)

    > CI (지속적 통합, Continuous Integration) = TBD (트렁크 기반 개발, Trunk-Based Development)

  - CI + 리팩터링 → **XP(익스트림 프로그래밍, eXtreme Programming)**

#### 테스팅

- 리팩터링을 위해서는 오류 파악을 위해 **자가 테스트 코드(self-testing code)** 를 마련해야 함
  - 리팩토링 과정에서 버그가 생길 위험을 제거하고, 테스트 실패 시 이전 버전과 비교하기 쉬움
- 자동 리팩터링 기능(안전한 리팩토링)을 제공하는 환경을 활용하는 방법도 있음 (ex. IntelliJ의 메서드 추출 기능 등)

#### 레거시 코드

> 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많음 (무엇보다 다른 사람이 작성한 것)

- 레거시 시스템에서 테스트를 보강하고, 리팩토링을 진행하면서 시스템을 더욱 쉽게 파악할 수 있음

  - 그럼에도 레거시 코드는 매우 복잡하기 때문에, <u>자주 보는 부분을 우선적으로 리팩터링</u>하는 방식을 추천

  > [**『레거시 코드 활용 전략』 (에이콘, 2018)**](https://www.yes24.com/Product/Goods/64586851) 에 나온 지침을 충실히 따르는 것을 추천

#### 데이터베이스

- **진화형 데이터베이스 설계(evolutionary database design)**와 **데이터베이스 리팩터링 기법** 활용

  - 커다란 변경들을 쉽게 조합하고 다룰 수 있는 <u>데이터 마이그레이션 스크립트</u> 작성 → 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 **통합 처리**
  - 마이그레이션 스크립트를 <u>작고 독립된 단계들로 쪼개어 작성</u>하고, 버전 관리 시스템에 순차적으로 저장하여 오류를 방지

- **병렬 수정 (parallel change) = 팽창-수축 (expand-contract)**

  > 데이터베이스의 필드 이름을 바꾸는 경우 예시

  - 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지 않음
  - 기존 필드와 새 필드를 동시에 업데이트 하도록 설정
  - 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체 (이 과정에서 발생하는 버그도 함께 해결)
  - 교체 작업이 끝나면, 더는 필요가 없어진 예전 필드를 삭제

<br>

## 리팩터링, 아키텍처, 애그니(YAGNI)

- **유연성 매커니즘 (flexibility mechanism)** : 함수를 정의할 때 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가
  - 매개변수를 생각나는 대로 추가하다 보면 <u>당장의 쓰임에 비해 너무 복잡해질 수 있음</u>
- **애그니(YAGNI, "you aren't going to need it", 필요 없을 거다) 설계 방식**
  - 일단 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축
  - 이후 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾸어 나감
    - 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하고, 복잡도를 높일 수 있는 유연성 매커니즘은 검을 거친 후 추가
  - 선제적인 아키텍처에 소홀해도 된다는 뜻은 아님 → 단지, 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 낫다고 생각하는 편
    - 이러한 경향은 **진화형 아키텍처(evolutionary architecture)** 원칙이 발전하는 계기가 되었음

<br>

## 리팩터링과 소프트웨어 개발 프로세스

- **XP (익스트림 프로그래밍) 의 두드러진 특징** : 지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스

  > 자가 테스트 코드 + 리팩터링 → **TDD (테스트 주도 개발, Test-Driven Development)**

  - **지속적 통합** : 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있음
  - **자가 테스트 코드** : 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 함

- <u>XP 의 주요한 세 가지 실천법</u>을 적용한다면 **YAGNI 설계 방식**으로 개발을 진행할 수 있음

<br>

## 리팩터링과 성능

- 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 <u>원하는 속도가 나게끔 튜닝</u>하는 것

- **빠른 소프트웨어를 작성하는 방법 세 가지**

  - **시간 예산 분배(time budgeting)** : 하드 리얼타임 시스템에서 많이 사용

    - 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 <u>자원(시간과 공간) 예산을 할당</u>
    - 컴포넌트는 할당된 자원 예산을 초과할 수 없고, 주어진 자원을 서로 주고받는 메커니즘을 제공할 수는 있음

    > 하드 리얼타임 시스템 : 계산의 정확성 뿐 아니라 시간 제약도 엄격히 준수하여야 하는 실시간 시스템

  - **끊임없이 관심을 기울이는 것** : 성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변할 수 있으니 유의

  - **성능 최적화에 돌입하기 전까지는 코드를 다루기 쉽게 만드는데 집중**

    - 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비함
    - 코드 전체를 고르게 최적화하기보다 시간을 많이 소비하는 부분을 집중적으로 최적화

- **리팩터링이 최적화에 도움되는 두 가지 면**

  - 성능 튜닝에 투입할 시간을 벌 수 있음 (기능 추가가 빨리 끝나기 때문)
  - 성능을 더 세밀하게 분석할 수 있음 → 프로파일러가 지적해주는 코드의 범위가 좁아져, 튜닝하기 더욱 쉬워짐

<br>

## 리팩터링 자동화

- **IntelliJ IDEA (인텔리제이 IDEA)** 나 **eclipse (이클립스)** 에서는 자바로 프로그래밍할 때 <u>메뉴 클릭만으로 리팩터링이 가능</u>
  - IDE 는 <u>텍스트와 구문 트리를 함께 활용</u>하여 리팩터링뿐 아니라 코드 탐색과 린팅을 비롯한 다양한 기능을 구현함
  - **정적 타입 언어**의 경우 안전하게 구현할 수 있는 리팩터링 수가 늘어남