# 반복자 패턴
## 문제 상황
- 어떠한 객체들의 컬렉션을 순회해야하는 상황
	- 리스트 같은 컬렉션이 있으면 쉽게 해결할 수 있겠지만, 
	- 루프를 처리하거나, 트리의 순회 등은 어떻게 처리하면 좋을지?
- 컬렉션의 주요 책임은 효율적 데이터 저장
	- 순회 알고리즘들을 추가할수록 책임이 불명확해짐

## 문제 해결 방법
- 컬렉션 순회 동작을 **반복자**라는 별도의 객체로 추출
	- 반복자 객체는 알고리즘 구현 외에도 순환에 대한 세부 정보(현재 위치, 남은 요소의 수 등)을 캡슐화할 수 있음

## 패턴 구조
- 반복자 : 인터페이스는 컬렉션의 순회에 필요한 작업을 선언
- 구산 반복자 : 컬렉션 순회를 위한 특정 알고리즘 구현, 반복자 객체는 순회의 진행 상황을 자체적으로 추적, 여러 반복자들이 같은 컬렉션을 독립적으로 순회 가능
- 컬렉션 : 컬렉션과 호환되는 반복자들을 가져오기위한 하나 이상의 메서드 선언
- 구상 컬렉션 : 클라이언트가 요청할 때마다 특정 구상 반복자 클래스의 새 인스턴스 반환
- 클라이언트 : 반복자들과 컬렉션들의 인터페이스를 통해 그들과 함께 작동

## 적용
- 컬렉션이 내부에 복잡한 데이터 구조가 있지만, 이 구조의 복잡성을 보안이나 편의상의 이유로 클라이언트들로부터 숨기고 싶을 때 사용
	- 데이터 구조와 작업 시의 세부 사항을 캡슐화하여 클라이언트에 컬렉션 요소들에 접근할 수 있는 몇 가지 간단한 메서드 제공
	- 클라이언트에 매우 편리하게 제공 가능
	- 클라이언트의 부주의하거나 악의적인 행동으로부터 컬렉션을 보호
- 앱 전체에서 순회 코드의 중복들 줄이기 위해 사용
	- 사소하지 않은 순회 알고리즘들의 코드는 부피가 큰 경향이 있고, 비즈니스 로직 내에 있으면 원래 코드 책임이 모호해질 수 있음
- 다른 데이터 구조들을 순회할 수 있기를 원할 때, 또는 이러한 구조들의 유형을 미리 알 수 없을 때 사용
	- 몇 개의 일반 인터페이스들을 제공

## 장단점
- ✅
	- **단일 책임 원칙** : 부피가 큰 순회 알고리즘들을 별도의 클래스들로 추출하여 클라이언트 코드와 컬렉션들을 정돈할 수 있음
	- **개방/폐쇄 원칙** : 새로운 유형의 컬렉션들과 반복자들을 구현할 수 있고, 아무것도 훼손하지 않을 체 기존의 코드에 전달할 수 있음
	- 컬렉션을 병렬로 순회할 수 있음
	- 순회를 지연하고 필요할 때 계속할 수 있음
- ❌
	- 앱이 단순한 컬렉션들과만 작동하는 경우 반복자 패턴은 과도할 수 있음
	- 박복자를 사용하는 것은 특수 컬렉션들의 요소들을 직접 탐색하는 것보다 덜 효율적일 수 있음

## 다른 패턴과의 관계
- **반복자**를 사용하여 [2-3. 복합체](../2.%20구조%20패턴/2-3.%20복합체.md)를 순회할 수 있음
- [1-1. 팩토리 메서드](../1.%20생성%20패턴/1-1.%20팩토리%20메서드.md)를 **반복자**와 함께 사용하여 컬렉션 자식 클래스들이 해당 컬렉션들과 호환되는 다양한 유형의 반복자들을 반환하도록 할 수 있음
- **메멘토**와 **반복자**를 함께 사용하여 순회 상태를 포착, 필요한 경우 롤백 가능
- **비지터**와 **반복자**를 함께 사용하여 데이터 구조를 순회하여 해당 구조의 요소들의 크래스들이 모두 다르더라도 이러한 요소들에 대해 어떤 작업 실행 가능
