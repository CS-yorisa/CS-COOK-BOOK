# 어댑터
## 문제 상황
![어댑터 문제 상황](https://refactoring.guru/images/patterns/diagrams/adapter/problem-ko.png?id=33ecccae252bded5eb70e070ddf28633)
- 주식 시장 모니터링 앱을 만드는 도중, XML 형식 데이터를 다운로드 하여 데이터 JSON을 활용하는 데이터 분석 라이브러리를 활용, 사용자에게 정보 제공
- 라이브러리가 JSON으로 동작하게 변경할 수 있으나, 코드의 손상 가능

## 해결 방법
- **어댑터**를 만들어서 해결할 수 있음
	- 어댑터는 한 객체의 인터페이스를 다른 객체가 이해할 수 있도록 변환하는 특별한 객체
	- 복잡성을 숨기기 위해 객체 중 하나를 래핑 (XML → JSON, 마일 → KM)
- 어댑터는 기존의 인터페이스를 받아서 사용하며, 양방향 어댑터를 만드는 것도 가능
![어댑터 해결 방법](https://refactoring.guru/images/patterns/diagrams/adapter/solution-ko.png?id=73504c03a6e85f8b6182ad1701232d16)
- XML 데이터 형식을 받아 라이브러리에서 동작하도록 JSON으로 변결할 수 있고, 해당 데이터를 활용한 결과를 사용자에게 제공
- 해외 여행에서의 전원 플러그를 활용하는 것처럼 실생활에도 적용할 수 있음

## 구조
### 객체 어댑터
![객체 어댑터](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter.png?id=33dffbe3aece294162440c7ddd3d5d4f)
- 객체 합성 원칙을 사용
	- 한 객체의 인터페이스를 구현, 다른 객체는 래핑
	- 거의 모든 언어로 구현 가능
- 클라이언트 : 프로그램의 기존 비즈니스 로직을 포함하는 클래스
- 클라이언트 인터페이스 : 다른 클래스들이 클라이언트 코드와 공동 작업할 수 있도록 따랴아 하는 프로토콜
- 서비스 : 일반적으로 타사 또는 레거시의 유용한 클래스
	- 클라이언트는 서비스를 직접 사용할 수 없음(호환되지 않는 인터페이스)
- 어댑터 : 클라이언트와 서비스 양쪽에서 작동할 수 있는 클래스
	- 서비스 객체를 래핑하는 동안 클라이언트 인터페이스 구현
	- 클라이언트로부터 호출을 수신한 후 객체가 이해할 수 있는 형식으로 변경

### 클래스 어댑터
![클래스 어댑터](https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter.png?id=e1c60240508146ed3b98ac562cc8e510)
- 상속을 사용하여, 어댑터는 동시에 두 객체의 인터페이스 상속
	- 다중 상속을 지원하는 언어에서만 구현 가능
- 객체를 래핑할 필요없이 오버라이딩된 메서드로 작동

## 어댑터 패턴 적용
- 기존 클래스를 사용하고 싶지만, 나머지 코드와 호환되지 않을 때 사용
- 부모 클래스에 추가할 수 없는 공통 기능들이없는 여러 기존 자식 클래스들을 재사용 하려는 경우 사용

## 어댑터 패턴 장단점
- 장점
	- 단일 책임 원칙, 비즈니스 로직에서 인터페이스, 데이터 변환 코드 등을 분리 가능
	- 개방/패쇄 원칙, 클라이언트 코드가 인터페이스를 통해 어댑터와 동작하는 한, 기존 코드를 손상시키지 않고 새로운 어댑터를 프로그램에 도입 가능
- 단점
	- 다수의 새로운 인터페이스, 클래스를 도입해야 하므로, 코드의 복잡성 증가
	- 때로는 코드 일부를 변경하는게 더 간단한 경우도 있음

## 다른 패턴과의 관계
- **브리지**는 사전에 설계하여 독립적으로 동작하게 하는 반면, **어댑터**는 기존 앱과 사용되어 호환되지 않던 일부 클래스들이 서로 잘 동작하도록 함
- **어댑터**는 기존 객체 인터페이스를 변경, 데코레이터는 **인터페이스**를 변경하지 않음
- **퍼사드**는 기존 객체를 위한 새 인터페이스 정의, **어댑터**는 기존 인터페이스를 사용할 수 있게 만듬