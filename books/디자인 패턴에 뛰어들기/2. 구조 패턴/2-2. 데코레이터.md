# 데코레이터 패턴 (래퍼 패턴)
## 문제 상황
- 알림 라이브러리를 만들고 있는 상황
- 초기 버전에서 `Notifier`클래스를 기반으로 생성, 단일 메서드 `send`만 가지고 있음
	- 어떠한 타사 앱으로부터 알림이 발생하면 알림 객체를 생성하여 사용자에게 알려줌
- 만약 추가적인 알림이 필요한 경우(이메일이나 다른 앱으로부터의 알림이 발생하는 경우), `Notifier`클래스를 확장하여 설계해야 함
- 추가적으로 여러개의 알림을 동시에 사용하려는 경우, 클래스 확장 등의 과정이 매우 복잡해 질 것

## 해결 방법
- 먼저 클래스 확장 방법을 고민해야 함
	- 상속은 정적, 런타임 때 기존 객체의 행동을 변경할 수 없음
	- 자식 클래스는 하나의 부모 클래스만 가질 수 있음 (대부분 언어에서 상속은 클래스가 동시에 여러 클래스의 행동을 상속하도록 허용하지 않음)
- 상속 대신 **집합 관계** 또는 **합성**을 사용
	- 집합 관계 : 객체 A가 객체 B를 포함, B는 A없이 생존할 수 없음
	- 합성 : 객체 A는 객체 B로 구성, A는 B의 수명 주기를 관리, B는 A없이 생존할 수 없음
- 새로운 방법을 적요하면 도우미 객체를 쉽게 대체하여 런타임 때 컨테이너의 행동 변경할 수 있음

- 래퍼

- `Notifier` 클래스에 적용

## 데코레이터 패턴 구조

- 컴포넌트
- 구상 컴포넌트
- 기초 데코레이터
- 구상 데코레이터
- 클라이언트

## 데코레이터 패턴 적용

## 구현 방법


### Python 데코레이터 vs 데코레이터 패턴
- https://stackoverflow.com/questions/8328824/what-is-the-difference-between-python-decorators-and-the-decorator-pattern
- **Decorator Pattern** - In object-oriented programming, the decorator pattern is a design pattern that allows behaviour to be added to an existing object dynamically. 
	- OOP의 디자인 패턴중 하나로, 객체 행동을 동적으로 조작 가능하게 해줌
- **Decorators in Python** - Despite the name, Python decorators are not an implementation of the decorator pattern. The decorator pattern is a design pattern used in statically typed object-oriented programming languages to allow functionality to be added to objects at run time; Python decorators add functionality to functions and methods at definition time, and thus are a higher-level construct than decorator-pattern classes.
	- 이름과는 다르게 데코레이터 패턴의 구현은 아님
	- 함수에 추가 기능을 부여하는 등의 작업을 하고, 데코레이터 패턴보다 고차원적 구현체임

## 장단점

## 다른 패턴과의 관계
- [2-1. 어댑터](2-1.%20어댑터.md)는 기존 객체의 인터페이스를 변경, **데코레이터**는 해당 객체의 인터페이스를 변경하지 않고 향상하며 어댑터를 사용할 때 불가능한 재귀적 합성 지원
- **어댑터**는 다른 인터페이스를, **프록시**는 같은 인터페이스를, **데코레이터**는 향상된 인터페이스를 래핑된 객체에 제공
- 책임 연쇄 패턴, 데코레이터 패턴
- 복합체 패턴, 데코레이터 패턴