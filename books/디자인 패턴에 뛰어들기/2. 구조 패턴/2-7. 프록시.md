# 프록시
## 문제 상황
![](https://refactoring.guru/images/patterns/diagrams/proxy/problem-ko.png?id=ab75180b50cdbd12af4a718a3b7e9c2f)
- 객체에 대한 접근 제한하는 이유는 객체가 필요할 때가 있지만, 항상 필요한 것은 아님
- 필요할 때만 객체를 만들어 지연된 초기화를 구현할 수 있지만,
	- 객체의 모든 클라이언트는 지연된 코드 실행하게되고 코드 중복 발생

## 해결 방법
![](https://refactoring.guru/images/patterns/diagrams/proxy/solution-ko.png?id=1c4cfc760f804ebf75f97a967fa2e562)
- 프록시 패턴은 원래 서비스 객체와 같은 인터페이스로 새 프록시 클래스 생성을 제안
	- 클라이언트로부터 요청을 받으면 프록시는 실제 서비스 객체를 생성, 모든 작업을 이 객체에 위임
- 클래스의 메인 로직 이전이나 이후에 무언가를 실행해야 하는 경우 프록시는 해당 클래스를 변경하지 않고도 무언가를 수행할 수 있도록 함
	- 프록시는 원래 클래스와 같은 인터페이스 구현, 실제 서비스 객체를 기대하는 모든 클라이언트에 전달 가능

## 실제 상황에 적용
![](https://refactoring.guru/images/patterns/diagrams/proxy/live-example.png?id=a268c57fdaf073ee81cf4dfc7239eae2)
- 신용 카드는 은행 계좌의 프록시, 은행 계좌는 현금의 프록시
	- 현금의 역할을 은행 계좌가, 은행 계좌의 역할을 신용 카드가 대체 가능
- 같은 인터페이스(은행) 에서 구현되어 같은 효과를 바라보며 사용 가능
	- 신용 카드를 사용 하는 것은 현금을 사용하는 것과 같은 효과를 볼 수 있음
- 한편으로 신용 카드를 분실하여도 은행 계좌, 현금을 분신할 것은 아니기 때문에 안전함

## 구조
![](https://refactoring.guru/images/patterns/diagrams/proxy/structure.png?id=f2478a82a84e1a1e512a8414bf1abd1c)
- 서비스 인터페이스 : 프록시가 서비스 객체로 위장할 수 있을면 서비스 인터페이스를 따라야 함
- 서비스 : 어떤 유용한 비즈니스 로직을 제공하는 클래스
- 프록시 : 클래스에는 서비스 객체를 가리키는 참조 필드가 있고, 프록시가 처리를 완료하면 처리된 요청을 서비스 객체에 전달
- 클라이언트 : 같은 인터페이스를 통해 서비스들 및 프록시들과 함께 동작

## 적용
- 지연된 초기화 (가상 프록시)
	- 앱이 시작될 때 객체를 생성하는 대신, 객체 초기화를 실제로 초기화가 필요한 시점까지 지연
- 접근 제어 (보호 프록시)
	- 클라리언트의 자격 증명이 어떤 정해진 기준과 일하는 경우에만 서비스 객체에 요청 전달 가능
- 원격 서비스 로컬 실행 (원격 프록시)
	- 네트워크를 통해 클라이언트 요청을 전달, 네트워크와의 작업의 모든 복잡한 세부 사항을 처리
- 요청들의 로깅 (로깅 프록시)
	- 프록시는 각 요청을 서비스에 전달하기 전에 로깅(기록) 할 수 있음
- 요청 결과들의 캐싱 (캐싱 프록시)
	- 프록시는 항상 같은 결과를 생성하는 반복 요청들에 대해 캐싱 구현 가능
	- 프록시는 요청들의 매개변수들을 캐시 키들로 사용 가능
- 스마트 참조
	- 서비스 객체 또는 그 결과에 대한 참조를 얻은 클라이언트들을 추적할 수 있음
	- 클라이언트가 서비스 객체를 수정했는지 추적 가능, 변경되지 않은 객체는 다른 클라이언트들이 재사용 가능

## 장단점
- ✅
	- 클라이언트들이 알지 못하는 상태에서 서비스 객체를 제어 가능
	- 클라이언트들이 신경 쓰지 않을 때 서비스 객체의 수명 주기 관기 가능
	- 프록시는 서비스 객체가 준비되지 않았거나 사용할 수 없는 경우에도 작동
	- 개방/폐쇄 원칙 : 서비스나 클라이언트들을 변경하지 않고도 새 프록시들을 도입 가능
- ❌
	- 새로운 클래스 도입으로 인하여 코드가 복잡해짐
	- 서비스 응답이 늦어질 수 있음

## 다른 패턴과의 관계
- [2-1. 어댑터](2-1.%20어댑터.md)는 다른 인터페이스를, **프록시**는 같은 인터페이스를, [2-4. 데코레이터](2-4.%20데코레이터.md)는 향상된 인터페이스를 래핑된 객체에 제공
- **퍼사드**는 복잡한 객체 또는 시스템을 보호하고 초기화 하는 점에서 **프록시**와 유사
	- **퍼사드**와 달리 **프록시**는 자신의 서비스 객체와 같은 인터페이스를 가지므로 상호 교환 가능
- **데코레이터**와 **프록시**는 구조는 비슷하나 의도가 다름
	- 두 패턴 모두 한 객체의 일부 작업을 다른 객체에 위임해야 하는 합성 원칙을 기반으로 함
	- **프록시**는 일반적으로 자체적으로 서비스 객체의 주기 관리
	- **데코레이터**의 합성은 항상 클라이언트에 의해 제어됨