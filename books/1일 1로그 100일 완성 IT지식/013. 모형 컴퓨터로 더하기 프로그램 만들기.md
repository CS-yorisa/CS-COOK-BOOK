[TOC]

# 013. 모형 컴퓨터로 더하기 프로그램 만들기

> 진짜는 아니지만 실제 컴퓨터의 속성을 많이 갖추고 있는 **'모형 컴퓨터'** 를 정의
>
> **시뮬레이터 :** https://www.cs.princeton.edu/courses/archive/fall21/cos109/toysim.html

- 1960년대 말에 사용되던 **미니컴퓨터** 정도의 수준

- 벅스, 골드스타인, 폰 노이만의 논문에 제시된 설계와 어느 정도 비슷함

- 명령어와 데이터를 저장하기 위한 **메모리**가 있음

  > 각 메모리 위치에 한 개의 수 또는 한 개의 명령어가 담겨 있음

- 한 개의 수를 담을 만한 용량의 부가적인 저장 영역인 **누산기(accumulator)**가 있음

  > 계산기에서 가장 최근에 입력한 수나 계산 결과를 담고 있는 **디스플레이**와 유사

- 모형 컴퓨터에는 앞서 설명했던 기본 연산을 수행하기 위한 **약 10개의 명령어 레퍼토리** 존재

  ![image](https://user-images.githubusercontent.com/87461594/175353509-054a0b4a-cc5b-4159-8048-4e15a6ff5ec7.png)

- 프로그램은 메모리에 저장된 일련의 명령어와 데이터 항목으로 구성됨

  > 작동을 시작하면 프로세서는 첫 번째 메모리 위치에서 시작해서 다음과 같이 단순한 사이클을 반복함

  ![image](https://user-images.githubusercontent.com/87461594/175346532-36729e11-2e2a-4bd4-94be-21c9523c5faf.png)

<br>

## 첫 번째 모형 프로그램

> 메모리가 정확히 다음 명령어들을 담고 있다고 가정 (메모리에 이진수로 저장)

```
GET
PRINT
STOP
```

**[프로그램 실행]**

1. **GET :** 사용자에게 수를 입력하도록 요청
2. **PRINT :** 그 수를 출력
3. **STOP :** 프로세서에 중지하라고 명령

> ![image](https://user-images.githubusercontent.com/87461594/175347493-ee254269-6bf5-417d-9ac1-56c831c61b3e.png)
>
> ![image](https://user-images.githubusercontent.com/87461594/175347739-99608439-868e-4c79-bfaa-e1daf7616756.png)

<br>

## 두 번째 모형 프로그램

> 메모리에 값을 저장한 후 그 값을 가져오기

```
    GET             (첫 번째 수를 입력받아 누산기에 넣는다.)
    STORE FirstNum  (FirstNum이라는 메모리 위치에 첫 번째 수를 저장한다.)
    GET             (두 번째 수를 입력받아 누산기에 넣는다.)
    ADD FirstNum    (첫 번째 수를 누산기에 있는 값에 더한다.)
    PRINT           (결과 합계 값을 출력한다.)
    STOP            (프로그램 실행을 중지한다.)
FirstNum:           (첫 번째 입력 수를 담을 메모리 위치)
```

- 6개의 명령어는 순서대로 **1~6 메모리에 저장**됨
- 첫 번째 수를 담을 공간 확보 필요 (FirstNum이라는 이름의 메모리 확보)

> ![image](https://user-images.githubusercontent.com/87461594/175349324-69ede0d9-71d6-482d-9cd9-4320f04ee7c6.png)
>
> ![image](https://user-images.githubusercontent.com/87461594/175349349-439d47f6-896e-4017-94be-387b38e45349.png)
>
> ![image](https://user-images.githubusercontent.com/87461594/175353680-198f206d-f57e-43a3-8d0e-4817a9d189e8.png)

<br>

## 분기 명령어

> 명령어 레퍼토리에 **일련의 명령어를 재사용**하게 하는 새로운 종류의 명령어 추가

```
Top: GET         (수를 입력받아 누산기에 넣는다.)
     IFZERO Bot  (누산기 값이 0이면 Bot 레이블이 붙은 명령어로 이동한다.)
     PRINT       (수를 출력한다.)
     GOTO Top    (Top으로 돌아가서 다른 수를 입력받는다.)
Bot: STOP
```

- **GOTO 명령어 :** 지정된 레이블로 이동 (위에서는 **Top** 이라는 레이블로 이동)

- **IFZERO 명령어 :** 값이 0인지 검사하여 만일 그렇다면 지정된 레이블로 이동 **(조건부 분기)**

- 분기를 통해 **이론상으로 '어떠한' 계산이든 수행**할 수 있도록 프로그래밍 가능

  > 실제로는 **프로세서 속도, 메모리 용량, 컴퓨터가 표현할 수 있는 수의 크기**가 한정적

<br>

## 일련의 수를 합산하는 모형 컴퓨터 프로그램

> 여러 개의 수를 합산하다가 숫자 0이 입력되면 실행을 멈추는 프로그램

```
Top: GET         (수를 입력받는다.)
     IFZERO Bot  (입력된 수가 0이면 Bot으로 간다.)
     ADD Sum     (가장 최근의 값에 누적 합계를 더한다.)
     STORE Sum   (결과를 새로운 누적 합계로 저장한다.)
     GOTO Top    (Top으로 돌아가서 다른 수를 입력받는다.)
Bot: LOAD Sum    (누적 합계를 누산기에 적재한다.)
     PRINT       (그리고 출력한다.)
     STOP
Sum: 0           (누적 합계를 담을 메모리 위치, 0으로 초기화)
```

<br>

## 메모리 내부 표현

> 명령어와 데이터가 **메모리 내부에서 표현되는 방법**

- GET은 **메모리 위치를 한 개 차지**

- 다른 메모리 위치도 참조하는 IFZERO, ADD 같은 명령어는 **메모리 두 개를 차지**

  > 두 번째 칸은 참조하는 위치에 해당

- 명령어의 숫자 값이 각각 다음과 같다고 가정

  > GET = 1, PRINT = 2, STORE = 3, LOAD = 4, ADD = 5, STOP = 6, GOTO = 7, IFZERO = 8

**[위의 프로그램 메모리 표현]**

![image](https://user-images.githubusercontent.com/87461594/175353047-b9bc2b97-f74a-466c-8f3d-83fb061a4e1d.png)