## 1.9 (1.2)

> ```js
> function plus(a, b) {
> 	return a === 0 ? b : inc(plus(dec(a), b))
> }
> function plus(a, b) {
> 	return a === 0 ? b : plus(dec(a), inc(a))
> }
> ```
>
> 주어진 인수를 1 증가시키는 `inc()`, 1 감소시키는 `dec()`를 이용해 두 양의 정수 덧셈 구현
> `plus(4, 5)`를 평가할 때, 각 함수가 생성하는 과정을 치환 모형으로 표현
> 이 과정들은 반복적인가 재귀적인가

```
plus(3, 6)
plus(2, 6) + 1
(plus(1, 6) + 1) + 1
((plus(0, 6) + 1) + 1) + 1
((6 + 1) + 1) + 1
9
```

- 첫 번째 함수는 재귀적으로 실행
  - 식이 완전히 전개된 후 축약되는 방식으로 정답을 구함

```
plus(3, 6)
plus(2, 7)
plus(1, 8)
plus(0, 9)
9
```

- 두 번째 함수는 반복적으로 실행
  - 식이 각 단계에서 특정 값을 기준으로 완성되는 방향으로 진행

## 1.10

- 애커만 함수(Ackermann function)
	- 원시 재귀 함수가 아닌 전역적인 재귀 함수(계산 가능 함수)의 가장 간단한 예시
	- 작은 값을 입력해도 그 값은 매우 빠르게 증가, $A(4,2) = 2^{65536} - 3$ 으로 19,729 자리 정수

```js
console.log(A(1, 10)); //1024
console.log(A(2, 4)); // 65536
console.log(A(3, 3)); // 65536
```

```js
function f(n) {
  return A(0, n);
} // n * 2

console.log(f(0)); // 0
console.log(f(1)); // 2
console.log(f(2)); // 4
console.log(f(3)); // 6

function g(n) {
  return A(1, n);
} // 2 ^ n

console.log(g(0)); // 0
console.log(g(1)); // 2
console.log(g(2)); // 4
console.log(g(3)); // 8
console.log(g(4)); // 16

function h(n) {
  return A(2, n);
} // 2 ^ h(n - 1)

console.log(h(0)); // 0
console.log(h(1)); // 2
console.log(h(2)); // 4
console.log(h(3)); // 16
console.log(h(4)); // 65536
// console.log(h(5)); max recursion error
```

## 1.11

```js
function fRecursive(x, y, z, n) {
  return n === 0 ? x : fRecursive(y, z, x * 3 + y * 2 + z, n - 1);
}

console.log(fRecursive(0, 1, 2, 1));
console.log(fRecursive(0, 1, 2, 2));
console.log(fRecursive(0, 1, 2, 3));
console.log(fRecursive(0, 1, 2, 4));
console.log(fRecursive(0, 1, 2, 5));
```

- 수열로 정의된 재귀 함수 대신, 반복적 과정으로 구하는 방식으로 변경
- x, y, z는 만나게 되는 3개 함의 값을 의미
	- 처음에는 f(0), f(1), f(2) 값을 의미함
- 다음에는 그 값을 차례로 갱신하는 방식
	- x, y 대신 y, z값을 사용, 새로 만나게 될 z값을 새롭게 갱신함

## 1.12

```js
function pascal(i, j) {
  // i 행 j 열의 값
  return i < j
    ? 0
    : i === 0 || j === 0
    ? 1
    : pascal(i - 1, j - 1) + pascal(i - 1, j);
}
```

- 삼각형의 범위를 벗어나면 0을 반환
- 삼각형의 모서리 (가장 왼쪽 혹은 오른쪽) 이면 1을 반환
- 아니라면 위의 두 값을 더하여 반환

## 1.13

$$
let\ \phi=\frac{1+\sqrt5}{2},\ \psi=\frac{1-\sqrt5}{2},\ Fib(n) = \frac{\phi^k-\psi^k}{\sqrt5}
$$

1. $n = 1, n = 2$ 일 때 성립

$$
\frac{\phi - \psi}{\sqrt5} = 1, \frac{\phi ^ 2 - \psi ^ 2}{\sqrt5} = 1
$$

2. $n = k - 1, n = k - 2$ 일 때 성립한다고 가정

$$
Fib(k) = Fib(k - 1) + Fib(k - 2) = \frac{\phi^{k - 1} - \psi^{k - 1}}{\sqrt5} + \frac{\phi^{k - 2} - \psi^{k - 2}}{\sqrt5} = \frac{\phi^{k - 2}(\phi + 1)}{\sqrt5} - \frac{\psi^{k - 2}(\psi + 1)}{\sqrt5}
$$

- 이 때, $\phi, \psi$의 값은 $x^2-x-1=0$의 두 해임을 알 수 있고, 따라서 $x^2=x + 1$이 된다.

$$
Fix(k) = \frac{\phi^k - \psi^k}{\sqrt5}
$$

3. $\frac{\psi^n}{\sqrt5}$ 가 -0.5 보다 크고, 0.5 보다 작음을 증명

$$
-0.5 < \psi = \frac{\psi^n}{\sqrt5} < 0.5
$$

- 위의 부등식은 n = 1일 때 성립하고, 따라서 n >= 2 이상인 경우에도 성립
- 따라서 $Fib(n)$ 은 $\frac{\phi^n}{\sqrt5}$에 가장 가까운 정수
