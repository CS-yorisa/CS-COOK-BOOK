## 1.6

> 문자 ?와 :가 관려하는 조건부 표현식이 마음에 들지 않았던 알리사 P. 해커
> 일반 조건부 표현식처럼 작동하는 조건부 함수 사용
> ```js
> fucntion  conditinal(predicate, then_clause, else_clause) {
> 	return predicate ? then_clause : else_clause;
> }
> ```
> 위의 conditinal 함수를 사용해 제곱근 계산 함수 작성
> ```js
> function sqrt_iter(guess, x) {
>   return conditional(
>     is_good_enough(guess, x),
>     guess,
>     sqrt_iter(improve(guess, x), x)
>   );
> } 
> ```
> 위 함수로 제곱근을 계산하면 어떤일이 생기는지 설명하라

- 먼저 조건 검사를 위해 `is_good_enough()`를 실행하는 것이 아니라, 함수 인자를 먼저 계산하게 되어, `sqrt_iter()`함수가 무한 호출됨

## 1.7

> 제곱근 계산에 쓰인 `is_good_enough` 술어 판정은 아주 작은 수의 제곱근을 구할 때 효과적이지 않음
> 실제 컴퓨터에서 산술 연산의 정밀도가 제한된 상태로 수행되기 때문에, 아주 큰 수의 제곱근 계산에 부적절
> - 작은 수와 큰 수에 대해 판정이 실패하는 사례들을 제시하라
> 
> `is_good_enough`를 구현하는 또 다른 전략은 반복 과정에서 guess의 변화량을 추적하면서 변화량이 아주 작은 비율보다 충분히 작으면 추측값이라고 판정
> 
> - 이런 종류의 반복 종료 판정 방식을 사용하는 제곱근 함수 설계
> - 작은 수와 큰 수에 대해 본문의 함수보다 잘 동작하는가?

```js
// 비율을 활용하여 추측
function ratio_is_good_enough(guess, x) {
  return abs(square(guess) - x) / abs(x) < 0.001;
}

function ratio_sqrt_iter(guess, x) {
  return ratio_is_good_enough(guess, x)
    ? guess
    : ratio_sqrt_iter(improve(guess, x), x);
}

function ratio_sqrt(x) {
  return ratio_sqrt_iter(1, x);
}
```

- 제곱근의 오차를 비율로 계산하는 방식으로 다시 구현

```js
// 작은 수에 대한 판정
let x = 0.00001;
let relative = sqrt(x);
let ratio = ratio_sqrt(x);

console.log(relative); // 0.03135649010771716
console.log(ratio); //0.0031622926477232706

console.log(square(relative), abs(x - square(relative))); // 0.0009832294718753643 0.0009732294718753642
console.log(square(ratio), abs(x - square(ratio))); // 0.000010000094789844653 9.478984465262992e-11

// 큰 수에 대한 판정
x = 1000000;
relative = sqrt(x);
ratio = ratio_sqrt(x);

console.log(square(relative)); // 1000000.0000000236
console.log(square(ratio)); // 1000000.3066033493
```

- 작은 수 0.00001의 제곱근을 구한 후 다시 제곱을 하는 방법으로 확인
	- 책에서 제시된 상대적인 값의 차이로 비교한 경우, 오차가 매우 크게 발생(자리수가 달라짐)
	- 반면 비율로 계산한 경우 오차가, 소수점 아래 10자리 까지 오차 발생하지 않음
	- 제곱근의 값만 비교하면 큰 차이 없어보이지만, 다시 제곱을 하여 비교해보면 원래 숫자와 오차카 커진것을 알 수 있음
- 반면 큰 수에 대한 경우
	- 책에서 제시된 방법처럼 두 수의 상대적 크기로 비교하는것이 더 정확하게 나온 반면,
	- 수의 비율로 계산한 경우 오차가 더 커지게 됨

## 1.8

> 세제곱근을 구하는 함수를 구현하라

```js
// 수의 차이를 비교하는 식을 함수로 표현
function improve(guess, x) {
  return (x / square(guess) + 2 * guess) / 3;

function sqrt3_iter(guess, x) {
  return is_good_enough(guess, x) ? guess : sqrt3_iter(improve(guess, x), x);
}

function sqrt3(x) {
  return sqrt3_iter(1, x);
}

console.log(sqrt3(8)); // 2.000004911675504
console.log(cubic(sqrt3(8))); //8.000058940250797
```

- 우선 근사값을 구하기 위한 다음 식, $\frac{x/y^2 + 2y}{3}$ 을 함수로 변경하여 적용
- 나머지 수식은 기존 제곱근을 구하는 방식과 유사하게 구현

## 1.9 (1.2)

> ```js
> function plus(a, b) {
> 	return a === 0 ? b : inc(plus(dec(a), b))
> }
> function plus(a, b) {
> 	return a === 0 ? b : plus(dec(a), inc(a))
> }
> ```
> 주어진 인수를 1 증가시키는 `inc()`, 1 감소시키는 `dec()`를 이용해 두 양의 정수 덧셈 구현
> `plus(4, 5)`를 평가할 때, 각 함수가 생성하는 과정을 치환 모형으로 표현
> 이 과정들은 반복적인가 재귀적인가

```
plus(3, 6)
plus(2, 6) + 1
(plus(1, 6) + 1) + 1
((plus(0, 6) + 1) + 1) + 1
((6 + 1) + 1) + 1
9
```

- 첫 번째 함수는 재귀적으로 실행
	- 식이 완전히 전개된 후 축약되는 방식으로 정답을 구함

```
plus(3, 6)
plus(2, 7)
plus(1, 8)
plus(0, 9)
9
```

- 두 번째 함수는 반복적으로 실행
	- 식이 각 단계에서 특정 값을 기준으로 완성되는 방향으로 진행
