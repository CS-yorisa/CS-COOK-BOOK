## 2.2.3 합의된 인터페이스로서의 순차열

- 합의된 인터페이스 (conventional interface) 설계원리

```javascript
function sum_odd_squares(tree) {
    return is_null(tree)
        ? 0
        : ! is_pair(tree)
        ? is_odd(tree) ? square(tree) : 0
        : sum_odd_squares(head(tree)) + sum_odd_squares(tail(tree))
}
```

- $2.2.2 에서 나온 `count_leaves`함수를 일부 변형하여 수치가 홀수인 잎을 골라 수의 제곱을 합함

```javascript
function even_fibs(n) {
    function next(k) {
        if (k > n) {
            return null
        } else {
            const f = fib(k)
            return is_even(f)
                ? pair(f, next(k + 1))
                : next(k + 1)
        }
    }
    return next(0)
}
```

- 짝수 피보나치 수들로 이루어진 목록을 생성하는 함수

- 위의 두 함수는 이전의 함수와 조금 다른 구조 but 유사한 부분이 많음. 두 함수의 작동을 추상적으로 나타내면
    - `sum_odd_squares()`
        - 트리의 잎을 나열
        - 홀수 잎을 선택하는 필터 적용
        - 선택된 수치를 제곱
        - 0에서 출발, `+`를 활용해 제곱을 누산
    - `even_fib()`
        - 0에서 n까지 정수 나열
        - 각 정수의 index를 사용해 피보나치 수 계산
        - 짝수 피보나치 수를 선택하는 필터 적용
        - 빈 목록에서 출발, `pair`를 이용해 피보나치 수들을 누산(누적)
    - 두 함수의 구조가 유사한 부분은 많지만, 그것을 명확하게 드러내지는 못함

### 순차열 연산들

- 신호 흐름이 더 명확하게 드러나도록 조직화하기 위해, 다음 단계로 흘러가는 신호를 집중

```
map(square, list(1, 2, 3, 4, 5));
> list(1, 4, 9, 16, 25)
```

- 위와 같이 순차적으로 적용 및 표현하여 신호 흐름을 나타낼 수 있음

```js
function filter(predicate, sequence) {
    return is_null(sequence)
        ? null
        : predicate(head(sequence))
        ? pair(head(sequence), filter(predicate, tail(sequence)))
        : filter(predicate, tail(sequence))
}

filter(is_odd, list(1, 2, 3, 4, 5, 6))
// list(1, 3, 5)

function accumulate(op, initial, sequence) {
    return is_null(sequence)
    ? pair(head(sequence), filter(predicate), tail(sequence))
    : filter(predicate, tail(sequence))
}

accumulate(plus, 0, list(1, 2, 3, 4, 5))
// 15
```

- 홀수 순차열을 필터하는 함수나, 누산하는 함수를 신호 흐름을 강조하여 나타낼 수 있음
- 위의 함수를 활용, 순차열 요소를 열거하는 단계를 구현하면 신호 흐름 구조 완성

```js
function enumerate_interval(low, high) {
    return low > high
        ? null
        : pair(low, enumerate(low + 1, high))
}

enumerate_interval(2, 7)
// list(2, 3, 4, 5, 6, 7)
```

- 구간의 값을 지정하여 배열을 누산하는 함수

```js
function enumerate_tree(tree) {
    return is_null(tree)
        ? tree
        : null
        : ! is_pair(tree)
        ? list(tree)
        : append(enumerate_tree(head(tree)), enumerate(tail(tree)))
}

enumerate_tree(list(1, list(2, list(3, 4)), 5))
```

- `sum_ood_squares`를 위한 트리 잎들의 열거에 사용

```js
function sum_odd_squares(tree) {
    return accumulate(
        plus,
        0,
        map(square, filter(is_odd, enumerate(tree)))
    )
}
```

- 위의 함수들을 사용하여 신호 흐름 구현
    - 트리의잎 열거 > 필터로 홀수 잎만 선택 -> 각 요소 제곱 -> 합

```js
function even_fib(n) {
    return accumulate(
        pair,
        null,
        filter(
            is_even,
            map(fib, enumerate(interval(0, n)))
        )
    )
}
```

- 0에서 n까지 정수를 열거 > 각 정수로 피보나치 수 생성 > 짝수 피보나치 수 선택 > 목록 만들기
- 위와 같은 방식으로 순차열 연산 형태는 모듈식 설계에 도움이 됨
    - *모듈실 설계*  : 비교적 독립적 조각들을 조합, 프로그램을 구축하는 방식
    - 표준적인 라이브러리, 그 구성요소들의 유연한 방식으로 연결하는 '합의된 인터페이스'가 있으면 모듈식 설계가 원활해짐
    - 모듈식 설계는 복잡성 제어에 큰 위력을 보여줌

```js
function list_fib_squares(n) {
    return accumulate(
        pair,
        null,
        map(
            square,
            map(fib, enumerate_interval(0, n))
        )
    )
}

list_fib_square(10)
// list(0, 1, 1, 4, 9, 25, 64, 169, 441, 1156, 3025)
```

- n + 1개의 피보나치 수들의 제곱으로 이루어진 목록을 구축하는 프로그램을 작성하며 위에서 작성함 함수를 활용

```js
function product_of_squares_of_odd_elements(sequence) {
    return accumulate(
        times,
        i,
        map(square, filter(is_odd, sequence))
    )
}

product_of_squares_of_odd_elements(1, 2, 3, 4, 5)
// 225
```

- 순차열에 있는 홀수 정수들의 제곱들의 곱을 계산하는 함수


### 중첩된 매핑

- 순차열 패러다임을 확장하면 중첩 루프로 표현되는 여러 계산도 순차열 패러다임에 포함시킬 수 있음
    - $1  \le j \lt i \le n$에 대해 $i + j$가 소수라는 조건을 충족하는 i, j 순서 쌍을 모두 구하고자 할 때
    - n보다 작거나 같은 모든 양의 정수 순서 쌍 생성, 필터로 합이 소수인 것 선택, 각 쌍에 대해 $(i, j, i+j)$ 생성

```js
accumulate(
    append,
    null,
    map(
        i => map(
            j => list(i, j), enumerate_interval(1, i - 1))
        ),
        enumerate_interval(1, n)
    )
)

function flatmap(f, seq) {
    return accumulate(append, null, map(f, seq))
}
```

- `enumerate_interval()`을 중첩으로 활용, 매핑으로 값을 누적하는 방식으로 구현 가능
- 위와 같은 방식이 많이 사용되므로, `append`로 누산하는 개별 함수 생성

```js
function is_prime_sum(pair) {
    return is_prime(head(pair) + head(tail(pair)))
}
```

- 순서쌍 순차열에 필터를 적용해서 합이 소수인 것을 생성

```js
function make_pair_sum(pair) {
    return list(
        head(pair), head(tail(pair)),
        head(pair) + head(tail(pair))
    )
}
```

- 필터로 선택한 각 쌍에 대해 두 정수와 그 합으로 이루어진 세 쌍 값을 생성

```js
function prime_sum_pair(n) {
    return map(
        make_pair_sum,
        filter(
            is_prime_sum,
            flatmap(
                i => map(i => list(i, j), enumerate_interval(1, i -1))
                enumerate_interval(1, n)
            )
        )
    )
}
```

- 위의 단계를 결합해 하나의 함수로 생성
- 중첩된 매핑은 수들을 나열한 순쳐열이 아닌 경에도 유용
    - 집합 S의 모든 순열을 생성한다고 할 때, 재귀적인 방법으로 가능함

```js
function permutations(s) {
    return is_null(s)
        ? list(null)
        : flatmap(
            x => map(p => pair(x, p), permutation(remove(x, s))),
            s
        )
}

function remove(item, sequence) {
    return filter(
        x => ! (x === item),
        sequence
    )
}
```

- S의 순열을 생성하는 문제를 S보다 원소가 적은 집합의 순열들을 생성하는 문제로 축소하는 방식으로 해결

## 2.2.4 예제: 그림 언어
