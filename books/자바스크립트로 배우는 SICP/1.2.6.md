## 1.2.6 예제: 소수 판정

- 주어진 정수 n 이 소수(prime)인지 판정하는 두 가지 설명

### 약수 찾기

```js
function smallest_divisor(n) {
	return find_divisor(n, 2)
}

function find_divisor(n, test_divisor) {
	return square(test_divisor) > n
		? n
		: divides(test_divisor, n)
		? test_divisor
		: find_divisor(n, test_divisor + 1)
}

function divides(a, b) {
	return b % a === 0
}
```

- 어떤 정수를 2 이상의 모든 정수로 나누어 보는 방법
- `find_divisor`의 재귀 종료 판정은 $n$이 소수가 아니면 $\sqrt n$보다 작거나 같은 같은 약수가 존재한다는 사실에 기초
	- 따라서 $n$이 소수인지 판정하는 데 필요한 단계 수의 증가 차수는 $\Theta (\sqrt n)$

### 페르마 판정법

- $\Theta (log n)$ 차수의 판정은 페르마 소정리에 기초

> 페르마의 소정리 : 만일 $n$이 소수이고, $a$가 $n$보다 작은 임의의 양의 정수이면, $a$의 $n$제곱은 $n$을 법으로 하여(modulo) $a$와 합동이다

- 즉, $a^p \equiv a (modulo \ p)$ 이 성립
	- $p=5$일 때, $a=1 \ \And \ a^5 = 1$, $a=2 \ \And \ a^5 = 32$, $a=3 \ \And \ a^5 = 243$, $a=4 \ \And \ a^5 = 1024$

```js
function expmod(base, exp, m) {
	return emp === 0
		? 1
		: is_even(exp)
		? square(expmod(base, exp / 2, m)) % m
		: (base * expmod(base, exp - 1, m)) % m
}

function fermat_test(n) {
	function try_it(a) {
		return expmod(a, n, n) === a
	}
	return try_it(1 + math_floor(math_random() * (n - 1)))
}

function fast_is_prime(n, times) {
	return times === 0
		? true
		: fermat_test(n)
		? fast_is_prime(n, times - 1)
		: false
}
```

- `expmod()` : 페르마 판정법을 구현하려면, 한 수의 거듭제곱을 다른 수로 나눈 나머지를 계산하는 함수가 필요
- `fetmat_test()` : $[1,n-1]$ 구간에서 무작위 정수 a를 선택하고, 페르마의 소정리를 만족하는지 판정
	- a는 원시 함수 `math_random()`을 이용해 선택, 한 후 n-1을 곱하여 적절한 난수 생성
- `fast_is_prime()` : times로 주어진 횟수만큼 판정 실행

### 확률적 방법

- 익숙한 대부분의 알고리즘은 반드시 정확한 답을 산출, 페르마 판정법은 그렇지 않음 
	- 페르마 판정법으로 얻은 답은 확률적으로만 정확함
	- 판정을 통과하지 않으면 수소가 아니지만, 판정을 통과했다 하더라도 소수라는 보장은 없음
		- 소수가 아니더라도 $a^p \equiv a (modulo \ p)$을 만족하는 p가 있을 수 있음
- 오류 확률이 있는 알고리즘에서, 오류 확률을 낮추는 전략이 중요함
- **확률적 알고리즘** : 위와 같이 확률적으로 틀릴 수 있는 알고리즘
