## 1.2

> 다음 수식을 자바스크립트 표현식으로 옮겨라
> $$
> \frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}
> $$
> 

``` javascript
(5 + 4 + ( 2 - ( 3 - ( 6 + ( 4 / 5 ))))) / (3 * (6 - 2) * ( 2 - 7))
```

연산자는 왼쪽 결합. 왼쪽에서 오른쪽으로 평가됨



## 1.3

> 세 개의 수를 받고 셋 중 가장 작은 것을 제외한 두 수의 제곱들을 합한 결과를 돌려주는 함수 선언

``` javascript
function square(x){
  return x*x;
}

function plus(x, y){
  return square(x) + square(y);
}

function except_min(x, y, z){
  return x >= z && y >= z ? plus(x, y) : x >= y && z >= y ? plus(x, z) : plus(y, z);
}
```



## 1.4

> 함수 적용 평가 모형은 함수 표현식이 복합 표현식인 경우도 허용
>
> 이를 고려하여 a_plus_abs_b 함수의 작동 방식 서술

``` javascript
function plus(a, b){
  return a + b;
}
function minus(a, b){
  return a - b;
}
function a_plus_abs_b(a, b){
  return (b >= 0 ? plus : minus)(a, b)
}
```



1. a_plus_abs_b(a,b) 의 매개변수 인수 a, b  평가 (4 +1 ,3+9 ) 등으로 되어 있으면 인수가 먼저 5, 12 로 평가됨
2. 술어 평가 (b >= 0)
3. 참일 경우 귀결 표현식 함수 평가 (plus)
4. 거짓일 경우 최종 대안 표현식 함수 평가 (minus)



## 1.5

> 주어진 해석기가 인수 우선 평가를 사용하는지 정상 순서 평가를 사용하는지 파악하는 방법 고안.
>
> 다음과 같은 함수가 주어질 때 해당 문장을 평가할 경우 인수 우선평가와 정상 순서 평가의 평가 순서를 서술

``` javascript
function p() {
  return p();
}

function test(x, y){
  return x === 0 ? 0 : y;
}

// 해석기 평가 대상
test(0, p(0));
```



- 인수 우선 평가

  test(0,  p()) 에서 인수인 0과 p()를 먼저 평가 -> p()는 재귀 호출로 test라는 function은 실행되지 못하고 p() 무한루프에 빠짐

- 정상 순서 평가

  test를 먼저 전개. 당장 필요하지 않은 인수 계산은 나중으로 미룸.

  x === 0 ? 0 : y; 에서 x===0이 먼저 계산되고 true 값인 0이 출력. y는 확인되지 않고 버려지기 때문에 값은 0이 됨



## 1.6

> 문자 ?와 :가 관려하는 조건부 표현식이 마음에 들지 않았던 알리사 P. 해커
> 일반 조건부 표현식처럼 작동하는 조건부 함수 사용
>
> ```js
> fucntion  conditinal(predicate, then_clause, else_clause) {
> 	return predicate ? then_clause : else_clause;
> }
> ```
>
> 위의 conditinal 함수를 사용해 제곱근 계산 함수 작성
>
> ```js
> function sqrt_iter(guess, x) {
> return conditional(
>  is_good_enough(guess, x),
>  guess,
>  sqrt_iter(improve(guess, x), x)
> );
> } 
> ```
>
> 위 함수로 제곱근을 계산하면 어떤일이 생기는지 설명하라

- 먼저 조건 검사를 위해 `is_good_enough()`를 실행하는 것이 아니라, 함수 인자를 먼저 계산하게 되어, `sqrt_iter()`함수가 무한 호출됨

## 1.7

> 제곱근 계산에 쓰인 `is_good_enough` 술어 판정은 아주 작은 수의 제곱근을 구할 때 효과적이지 않음
> 실제 컴퓨터에서 산술 연산의 정밀도가 제한된 상태로 수행되기 때문에, 아주 큰 수의 제곱근 계산에 부적절
>
> - 작은 수와 큰 수에 대해 판정이 실패하는 사례들을 제시하라
>
> `is_good_enough`를 구현하는 또 다른 전략은 반복 과정에서 guess의 변화량을 추적하면서 변화량이 아주 작은 비율보다 충분히 작으면 추측값이라고 판정
>
> - 이런 종류의 반복 종료 판정 방식을 사용하는 제곱근 함수 설계
> - 작은 수와 큰 수에 대해 본문의 함수보다 잘 동작하는가?

```js
// 비율을 활용하여 추측
function ratio_is_good_enough(guess, x) {
  return abs(square(guess) - x) / abs(x) < 0.001;
}

function ratio_sqrt_iter(guess, x) {
  return ratio_is_good_enough(guess, x)
    ? guess
    : ratio_sqrt_iter(improve(guess, x), x);
}

function ratio_sqrt(x) {
  return ratio_sqrt_iter(1, x);
}
```

- 제곱근의 오차를 비율로 계산하는 방식으로 다시 구현

```js
// 작은 수에 대한 판정
let x = 0.00001;
let relative = sqrt(x);
let ratio = ratio_sqrt(x);

console.log(relative); // 0.03135649010771716
console.log(ratio); //0.0031622926477232706

console.log(square(relative), abs(x - square(relative))); // 0.0009832294718753643 0.0009732294718753642
console.log(square(ratio), abs(x - square(ratio))); // 0.000010000094789844653 9.478984465262992e-11

// 큰 수에 대한 판정
x = 1000000;
relative = sqrt(x);
ratio = ratio_sqrt(x);

console.log(square(relative)); // 1000000.0000000236
console.log(square(ratio)); // 1000000.3066033493
```

- 작은 수 0.00001의 제곱근을 구한 후 다시 제곱을 하는 방법으로 확인
  - 책에서 제시된 상대적인 값의 차이로 비교한 경우, 오차가 매우 크게 발생(자리수가 달라짐)
  - 반면 비율로 계산한 경우 오차가, 소수점 아래 10자리 까지 오차 발생하지 않음
  - 제곱근의 값만 비교하면 큰 차이 없어보이지만, 다시 제곱을 하여 비교해보면 원래 숫자와 오차카 커진것을 알 수 있음
- 반면 큰 수에 대한 경우
  - 책에서 제시된 방법처럼 두 수의 상대적 크기로 비교하는것이 더 정확하게 나온 반면,
  - 수의 비율로 계산한 경우 오차가 더 커지게 됨

## 1.8

> 세제곱근을 구하는 함수를 구현하라

```js
// 수의 차이를 비교하는 식을 함수로 표현
function improve(guess, x) {
  return (x / square(guess) + 2 * guess) / 3;

function sqrt3_iter(guess, x) {
  return is_good_enough(guess, x) ? guess : sqrt3_iter(improve(guess, x), x);
}

function sqrt3(x) {
  return sqrt3_iter(1, x);
}

console.log(sqrt3(8)); // 2.000004911675504
console.log(cubic(sqrt3(8))); //8.000058940250797
```

- 우선 근사값을 구하기 위한 다음 식, $\frac{x/y^2 + 2y}{3}$ 을 함수로 변경하여 적용
- 나머지 수식은 기존 제곱근을 구하는 방식과 유사하게 구현

## 1.9 (1.2)

> ```js
> function plus(a, b) {
> 	return a === 0 ? b : inc(plus(dec(a), b))
> }
> function plus(a, b) {
> 	return a === 0 ? b : plus(dec(a), inc(a))
> }
> ```
>
> 주어진 인수를 1 증가시키는 `inc()`, 1 감소시키는 `dec()`를 이용해 두 양의 정수 덧셈 구현
> `plus(4, 5)`를 평가할 때, 각 함수가 생성하는 과정을 치환 모형으로 표현
> 이 과정들은 반복적인가 재귀적인가

```
plus(3, 6)
plus(2, 6) + 1
(plus(1, 6) + 1) + 1
((plus(0, 6) + 1) + 1) + 1
((6 + 1) + 1) + 1
9
```

- 첫 번째 함수는 재귀적으로 실행
  - 식이 완전히 전개된 후 축약되는 방식으로 정답을 구함

```
plus(3, 6)
plus(2, 7)
plus(1, 8)
plus(0, 9)
9
```

- 두 번째 함수는 반복적으로 실행
  - 식이 각 단계에서 특정 값을 기준으로 완성되는 방향으로 진행
