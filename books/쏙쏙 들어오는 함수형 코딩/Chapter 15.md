# Chapter 15. 타임라인 격리하기

## 버그

- 천천히 클릭하면 동작에 문제가 없지만,
- 빠르게 여러번 클릭하는 경우 문제가 발생

```js
function add_item_to_cart(name, price, quantity) {
    cart = add_item(cart, name, price, quantity)
    calc_cart_total()
}

function cart_cart_total() {
    total = 0
    cost_ajax(cart, function(cost) { // 제품 API로 AJAX 요청 생성
        total += cost
        shipping_ajax(cart, function(shipping) { // 판매 API로 AJAX 요청 생성
            total += shipping
            update_total_dom(total) // 합계를 DOM에 보여주기
        })
    })
}
```

- 상품 추가 버튼을 누르게 되면 제품 API에서 가격을 얻고, 판매 API에서 최종 가격을 순차적으로 계산

## 문제가 발생하는 시간

- 사용자 클릭이 동시에 발생하게 되면,
    - 먼저 누른 행동에 대하여 DOM이 업데이트 되기 전, 또 다른 값을 읽어와 중복되어 적용됨

## 두 가지 타임라인 다이어그램 기본 규칙

- 여러개의 타임라인이 병렬로 실행되는 경우, 두 가지 규칙을 지켜야 함
    - 두 액션이 순서대로 나타나면 같은 타임라인에 넣음 (한 액션이 끝난 후 다른 액션이 실행될 수 있게)
    - 두 액션이 동시에 실행되거나, 순서를 예상할 수 없다면 시간을 추가

## 자세히 보면 좋칠 수 있는 액션 순서에 관한 사실

- `++`, `+=`는 사실 세 단계
    - 다양한 언어에서 위와 같은 연산을 지원하는데, 실제로는 세 단계를 거쳐 실행됨
    - 값을 읽고, 연산, 값을 쓰는 행동이 순차적으로 발생
- 인자는 함수를 부르기 전 실행
    - `console.log(some_function())`과 같은 경우, 함수 실행을 먼저하여 값을 얻고, 그 값을 콘솔에 출력

## `add-to-cart` 타임라인 그리기

- 위의 코드에서는 총 13개의 액션이 있고, 두 개의 비동키 콜백 호출이 있음

## 서로 다른 언어, 서로 다른 스레드 모델

- 단일 스레드, 동기
    - 멀티 스레드를 지원하지 않는 언어는 많음
    - PHP 등
    - 스레드가 하나이면 단순하다는 장점이 있지만, API 호출 등의 타임라인이 필요할 수 있음
- 단일 스레드, 비동기
    - JS 등
    - 입출력 작업을 할 대 비동기를 사용
    - 입출력 괄과를 콜백으로 받을 수 있지만, 언제 끝날지 알 수 없음
- 멀티 스래드
    - Java, Python, Ruby, C, C# 등
    - 실행 순서를 보장하지 않기 때문에 고려해야 하는 부분이 많아짐
- 메시지 패싱 프로세스
    - Elixir, Erlang 등
    - 서로 다른 프로세스를 동시에 실행할 수 있는 스레드 모델
    - 프로세스는 메모리를 공유하지 않기 때문에 실행 순서가 많아도 문제되지 않음

## `add-to-cart` 타임라인 그리기: 단계 2

- 위의 함수에서는 각 ajax 요청마다 순차적으로 비동기 동작이 이루어짐

## 동시에 실행되는 두 가지 종류의 코드

- 타임라인에서 순서대로 실행되는 코드에도
    - 순서가 섞일 수 있는 코드가 있고, 순서가 섞이지 않는 코드가 있음
    - 두 개의 액션이 순차적으로 이루어지면, 다른 액션이 그 사이에서 발생할 수 있음
    - 하지만, 두 개의 액션이 연속해서 이루어지면 다른 액션이 중간에서 실행될 수 없음
- 타임라인에서는 동시에 실행되는 코드가 있을 때, 어떤 액션이 먼저 실행되는지 알 수 없음
    - 그러한 경우 “가능한 순서”에 따라 다른 문제가 발생할 수있음

## 좋은 타임라인의 원칙

- 타임라인은 적을수록 이해하기 쉬움
    - 극단적으로 하나인 시스템이 이해하기 쉬움
- 타임라인은 짧을수록 이해하기 쉬움
- 공유하는 자원이 적을수록 이해하기 쉬움
- 자원을 공유하면 조율해야 함
- 시간은 일급으로 다룸

## 자바스크립트의 단일 스레드

- JS의 스레드 모델은 타임라인이 자원을 공유하며 생기는 문제를 줄여줌
    - 하나의 메인스레드에서 순차적으로 실행하면 됨
    - 따라서 두 개의 액션이 동시에 실행될 일이 없음
- 하지만, 비동기 콜백을 사용하는 경우 미래에 알 수 없는 시점에 실행되기 때문에 문제가 발생할 수 있음

## 자바스크립트의 비동기 큐

![](https://blog.kakaocdn.net/dn/bXG1CQ/btrd9j8bw80/LFkG7TkdwDSr1mCyw2957k/img.jpg)

- 브라우저에서 동작하는 JS 엔진은 **작업 큐**를 가지고 있고, **이벤트 루프**에 의해 처리
- 이벤트 루프: 큐에서 작업을 하나 끝내고 완료되면 다음 작업을 꺼내 실행하는 것을 무한 반복
    - 이벤트 루프는 단일 스레드에서 동작하기 때문에 동시에 여러 작업이 실행되지 않음
- 이벤트(마우스 클릭, 키보드 입력 등)이 발생하면 큐에 작업이 추가

## AJAX와 이벤트 큐

- AJAX는 브라우저 기반을 둔 웹 요청
- JS에 AJAX요청이 만들어지면, 추가적인 요청 큐에 넣음
    - 요청 큐에 들어간다면, 작업이 완료될 때 까지 기다리지 않고 다음 코드가 실행

## `add-to-cart` 타임라인 그리기: 단계 3

- 하나의 타임라인의 액션을 하나로 통합
    - 원래는 ajax 요청마다대기한 후 다른 작업이 실행되기 때문에 서로 다른 타임라인에 있었음
    - 대신, 하나의 ajax가 종료되면 다음 콜백을 이어서 작업하도록 함

## 요약: 타임라인 다이어그램 그리기

- 액션 확인
- 액션 그리기
    - 순서대로 실행되는 액션과, 비동기 콜백, 멀티 스레드와 같이 동시에 실행되는 액션이 있음
- 타임라인 단순화하기
    - 언어의 특징에 따라 순서가 보장되는 액션을 하나의 박스로 묶을 수 있음
- 타임라인 읽기

## 타임라인을 나란히 하여 문제를 해결하기

- 타임라인을 나란히 둘 수 있다면, 문제시점을 파악하기 쉬워짐
    - 두 번째 클릭이 첫 번째 클릭에 의한 ajax요청이 종료되기 전 실핼된다면 실행결과를 보장할 수 없음
- 만약 처음 클릭에 대한 모든 요청이 종료된 후 두 번째 클릭을 하면 전혀 문제가 없지만,
- 처음 클릭에 대한 요청이 종료되기 전 두번째 클릭을 한다면, 전체 실행순서가 변경되어 결과가 예측과 다르게 나올 수 있음

## 자원을 공유하는 타임라인은 문제가 생길 수 있음

- 위의 경우에서 같은 자원을 읽고 쓰는 액션을 함
    - 처음 클릭에 의해 카트의 값을 읽고 계산하는 도중
    - 두 전째 클릭에 의해 카트의 값을 다시 읽고 쓰는 과정에서 의도하지 않은 결과가 나옴
- 따라서 자원을 공유하는 액션이 있는 경우, 순서가 중요함

## 전역변수를 지역변수로 바꾸기

- total은 전역변수일 필요가 없음

```js
function calc_cart_total() {
    var total = 0 // 지역변수 활용
    cost_ajax(vart, function(cost) {
        totla += cost
        shipping_ajax(cart, function(shipping) {
            total += shipping
            update_total_dom(total)
        })
    })
}
```

- total을 전역변수로 활용한다면, 콜백함수에서 total 값이 0인 것이 보장되지 않음

## 전역변수를 인자로 바꾸기

```js
function add_item_to_cart(name, price, quantity) {
    cart = add_item(cart, name, price, quantity)
    calc_cart_total(cart)
}

function calc_cart_total(cart) { // 추가 인자 cart를 사용
    var total = 0
    cost_ajax(cart, function(cost) {
        totla += cost
        shipping_ajax(cart, function(shipping) {
            total += shopping
            update_total_dom(total)
        })
    })
}
```

- 암묵적 인자가 적은 액션이 좋은 액션이라는 앞선 내용을 따라 암묵적 인자를 입력으로 바꾸는 과정
- cart라는 전역변수를 사용하는 대신, 입력으로 변경

## 재사용하기 좋은 코드 만들기

```js
function calc_cart_total(cart, callback) {
    var total = 0
    cost_ajax(cart, function(cost) {
        totla += cost
        shipping_ajax(cart, function(shipping) {
            total += shopping
            callback(total)
        })
    })
}

function add_item_to_cart(name, price, quantity) {
    cart = add_item(cart, name, price, quantity)
    calc_cart_total(cart, update_total_dom)
}
```

- 기존코드는 무조건 dom 업데이트를 하므로 재사용성이 낮음
- dom을 업데이트하는 부분을 콜백으로 바꾸어, 쉽게 재사용할수 있도록 변경
