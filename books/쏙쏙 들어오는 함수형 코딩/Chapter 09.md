# 계층형 설계 II

## 패턴 2: 추상화 벽

- 추상화 벽은 다양한 문제를 해결하는데, 대표적으로 책임을 명확하게 나눌 수 있음

![](https://user-images.githubusercontent.com/109048739/209537098-f6c2fb1e-9fef-4d05-9f6a-9d1324e12de6.png)

- 위와같이 추상화 벽을 설치하면, 추상화 벽보다 아래에 있는 내용을 몰라도 됨
- 세부적인 행동을 감추게 되면, 기존 API를 사용하는 곳에서는 세부적인 구현을 알 필요 없는 장점이 있음

```js
function add_item(cart, itme) {
    // return add_element_last(cart, item)
    return objectSet(cart, item.name, itme)
}

function calc_total(cart) {
    var total = 0
    var names = Object.keys(cart)
    // for (var i=0; i<cart.length; i++) {
    for (var i=0; i<names.lengths; i++) {
        // var item = cart[i]
        var item = cart[name[i]]
        total += itme.price
    }
    return total
}

...
```

- 장바구니에서 사용하는 배열 탐색보다 해시맵 탐색이 더 효율적임
- 기존 장바구니를 배열로 구성한 것을 객체로 변경할 수 있음
- 이 과정에서 배열 또는 객체에 관한 구체적인 것을 알고 있지 않더라도(추상화의 벽 넘어의 신경쓰지 않고 구현할 수 잇음)
    - 위와같이 변경하는 과정에서 추상화의 벽(점선)을 가로지는 화살표가 없도록 하는것이 좋음

## 추상화의 벽은 언제 사용하면 좋을지?

- 쉽게 구현을 바꾸기 위해
    - 구현에 대한 확신이 없을 때, 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 때문에 구현을 바꾸기 쉬움
    - 한편으로는 데이터 구조가 변경되는것은 쉽지 않기 때문에, 나중에가서 변경하는것이 쉽지 않을 수 있음
- 코드를 읽고 쓰기 쉽게 만들기 위해
- 팀 간에 조율해야 할 것을 줄이기 위해
- 주어진 문제에 집중하기 위해

## 패턴 3: 작은 인터페이스

- 인터페이스를 최소화하여 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있음

### 시계를 할인하려고 함

```
if 장바구니 총합 > $100 and 장바구니에 시계가 있으면
    then 시계 10% 할인
```

- 특정 조건에 따라 시계를 할인하고자 함

### 시계 할인 마케팅을 위한 두 가지 방법

```js
// 방법 1: 추상화 벽에서 구현
function getsWatchDiscount(cart) {
    var total = 0
    var names = Obejct.keys(cart)
    for (var i=0; i<name.length; i++) {
        var itme = cart[names[i]]
        total += item.price
    }
    return total > 100 && cart.hasOwnProperty("watch")
}

// 방법 2: 추상화 벽 위에서 구현
function getWatchDiscount(cart) {
    var total = calcTotal(cart)
    var hasWatch = isInCart("watch")
    return total > 100 && hasWatch
}
```

- 할인을 위한 코드를 추상화 벽에 만들거나, 추상화 벽 위에 만드는 방법이 있음
    - 만약 추상화 벽에 있다면, 같은 계층에 있는 함수는 사용할 수 없음
    - 추상화 벽 위에 만든다면 해시 데이터 구조를 직접 접근할 수 없음

### 추상화 벽 위에 있는 계층에 구현하는 것이 더 좋음

- 추상화 벽에서 구현하는 것은 직접 구현에 더 가까운 방법이기 때문에, 추상화 벽 위에 구션하는 것이 좋음
- 첫 번째 방법을 사용해도 추상화 벽을 잘 유지할 수 있음
    - 하지만, 추상화 벽의 또 다른 목적을 위반함
    - 기존 코드를 사용하려는 마케팅 팀은 세부적인 구현에 신경쓰고 싶지 않음
- 추상화 벽에 구현하는 것, 팀간의 역할 구분과 관한 문제가 있을 수 있음
    - 추상화 벽에 더 많은 함수가 생긴다면 계층간 구현에서 더 많은 함수가 생기는 것이고,
    - 이러한 결과로 추상화 벽의 장점을 약화시킴
- 새로운 기능을 만들 때 하위 계층에 추가하는 것이 아니라, 상위 계층에 만드는 것이 작은 인터페이스를 만드는 것이라 할 수 있음
    - 작은 인터페이스를 사용하면, 하위 계층을 고치지 않고 상위 계층에서 문제를 해결할 수 있음

### 제품에 대한 로그를 남기는 기능

- 장바구니에 상품을 담을 때마다 로그를 남기는 기능 (`logAddToCart(user_id, item)`) 요청
- 로그를 남기는 좋은 위치는 어디일지? 로그를 남지는 장점은 무엇일지?

### 코드 위치에 대한 설계

- 장바구니에 제품을 담을 때 로그를 남겨야 하므로 `add_item()`함수에서 남기는것이 가장 쉬운 방법이며 합당해보임
    - 하지만, `add_item()`에서 로그를 남기는 것에는 문제가 있음
    - 로그를 남기는 함수는 액션인데, `add_item()`함수에서 실행하면 이 함수도 액션이 되고, 테스트하기 어려워짐
    - 또한 `add_itme()`은 다른 위치에서도 사용되는데, 그러한 위치마다 실행하는것은 코드를 개선하는데 도움되지 않음

### 로그를 남길 더 좋은 위치

- `logAddToCart()`함수는 액션이라는 사실과, 추상화 벽 위에 있어야 한다는 점을 알게 되었음

```js
function add_item_to_cart(name, price) {
    var itme = make_cart_item(name, price)
    shopping_cart = add_itme(shopping_cart, item)
    var total = calc_total(shopping_cart)
    set_cart_total_dom(total)
    update_shipping_icons(shopping_cart)
    update_tax_dom(total)
    logAddToCart()
}
```

- `add_itme_to_cart()` 는 상품을 장바구니에 담을 때 실행되는 핸들러 함수
    - 이 함수에서는 이미 액션을 실행하기 때문에, 함수 자체가 액션이 됨
    - 따라서 로그를 남기기에 적합한 위치로 보임

## 패턴 4: 편리한 계층

- 앞선 세 가지 패턴은 계층을 구성하기 위한 패턴
- 마지막 패턴은 앞선 패턴들과 조금 다르게 실용적인 측면을 다룸

- 커다란 계층은 강력해보이지만, 강력한 추상화 계층은 만들기 어려움
    - 실제 비즈니스에서 거대한 추상 계층을 만들 여유가 없음
- 지금 사용하는 계층이 편리하다면, 설계를 수정하고 개선하는 작업을 멈춰도 됨

## 그래프로 알 수 있는 코드에 대한 정보

- 호출 그래프에서 함수 이름을 제거하면, 구조에 대한 추상적 모습을 알 수 있음
- 호출 그래프의 구조는 세 가지 비기능적 요구사항을 보여줌
    - 기능적 요구사항은 소프트웨어가 정확히 해야 할 일을 말함
    - 비기능적 요구사항은 테스트를 어떻게 실행할지, 재사용을 잘할 수 있을지, 유지보수하기 쉬운지 등 *~성*에 관한 것
        - 유지보수성, 테스트성, 재사용성

## 그래프 가장 위에 있는 코드가 가장 고치기 쉬움

- 그래프에서 가장 위에 있는 함수는 고치기 쉬운 반면, 아래에 위치할수록 고치기 어렵고, 쉽게 변경해서는 안 됨

## 아래에 있는 코드는 테스트가 중요함

- 아래에 있는 코드일수록 변경하기 어려우므로, 테스트하는것이 중요함
- 테스트 코드를 만드는 것도 시간과 비용이 드는 작업이기 때문에, 
    - 모든 코드에 대한 테스트 코드가 있는 것이 좋을 수 있지만,
    - 제한된다면 변경이 적은 아래 계층의 코드부터 테스트를 하는것이 좋음

## 아래에 있는 코드가 재사용하기 좋음

- 코드 재사용은 새롭게 작성할 필요가 없어지기 때문에 시간과 비용을 줄일 수 있음
- 계층형 구조를 가진다면, 자연스럽게 아래 계층의 함수들이 더 자주 호출되기 때문에 재사용에 용이함
