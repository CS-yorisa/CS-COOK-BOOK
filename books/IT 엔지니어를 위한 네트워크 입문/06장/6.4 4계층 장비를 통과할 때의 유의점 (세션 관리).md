[TOC]

# 6.4 4계층 장비를 통과할 때의 유의점 (세션 관리)

> 세션 장비는 일반적인 2, 3계층 네트워크 장비와 달리 **세션을 이해**하고 **세션 테이블을 유지**

- 세션 테이블 정보를 이용해 **패킷을 변경**하거나 **애플리케이션 성능을 최적화**
- 보안을 강화하기 위해 패킷을 **포워드(Forward)**하거나 **드롭(Drop)**

<br>

## 6.4.1 세션 테이블 유지, 세션 정보 동기화

> 세션 장비는 한정된 메모리와 과도한 세션 방지를 위해 **적당한 세션 타임아웃값**을 유지

- **'세션 장비의 타임아웃값 < 애플리케이션의 타임아웃값'** 이 되는 경우 문제 발생
  - 양쪽 단말에서 세션이 유지되고 있는데, 중간 세션 장비의 세션이 만료되어 <u>통신이 막힘</u>

![image](https://user-images.githubusercontent.com/87461594/190891049-bb49b49b-25b0-465a-8fcb-80f91093cef8.png)

### 세션 만료 시 동작 순서

1. 3방향 핸드셰이크를 통해 정상적으로 세션 설정

   > ① 방화벽에서 세션 설정 과정을 확인하고 세션 테이블 기록

2. ②, ③ 세션 테이블을 참조해 방화벽에서 패킷 통과

3. 일정 시간 동안 통신 없음

4. ④ 세션 타임으로 세션 테이블 만료

5. 세션 만료 후 애플리케이션 통신 시작

6. ⑤ 세션이 만료되어 방화벽에서 패킷 드롭

> 이런 문제를 해결하기 위해 세션 장비와 애플리케이션에서 각각 설정 (하나만 적용되어도 해결가능)

<br>

### 6.4.1.1 세션 장비 운영자 입장

**가. 세션 만료 시간 증가**

- 애플리케이션의 세션 유지 시간보다 길게 설정 (**포트 번호**나 **IP 주소**마다 별도의 세션 만료 시간 설정 가능)

**나. 세션 시간을 둔 채로 중간 패킷을 수용할 수 있도록 방화벽 설정 (세션 장비 중 방화벽에 해당)**

- 세션 테이블에 정보가 없는 ACK 패킷이 들어오더라도 <u>세션을 새로 만들어 통과</u>
- **전체적인 보안**이 취약해질 수 있음

**다. 세션 장비에서 세션 타임아웃 시 양 단말에 세션 종료 통보**

- 양 종단 장비와 중간 세션 장비의 세션 정보가 일치하지 않을때 사용
- 세션 장비에서 세션 타임아웃 시 양 종단 장비에 **세션 정보 만료(RST)**를 통보

![image](https://user-images.githubusercontent.com/87461594/190892023-1d1482c3-f0d0-45e4-b22b-2ce6dd4b6d1d.png)

#### 세션 만료 시 동작 순서

1. 세션 설정
2. 일정 시간 동안 통신 없음
3. ① 세션 타임아웃값이 넘어 세션 만료
4. ② 방화벽에서 양 종단 장비에 RST 패킷 전송
   1. A, B 장비 통신일 경우
   2. A 장비에는 출발지 B, 도착지 A인 RST 패킷 전송
   3. B 장비에는 출발지 A, 도착지 B인 RST 패킷 전송
5. ③ RST 패킷을 받은 양 종단 장비는 해당 프로세스 종료

<br>

### 6.4.1.2 개발자 입장

**가. 애플리케이션에서 주기적인 패킷 발생 기능 추가**

- **더미 패킷(Dummy Packet)**을 보내는 기능을 추가하여 중간 방화벽의 세션 만료 방지
- 중간 세션 장비의 세션 만료 시간으로 인한 문제를 해결하는 **가장 바람직한 방법**

![image](https://user-images.githubusercontent.com/87461594/190892141-4aa69709-18bc-465d-8175-448bb77a5d7d.png)

<br>

## 6.4.2 비대칭 경로 문제

> 인바운드 패킷과 아웃바운드 패킷이 같은 장비를 통과하는 것을 **대칭 경로(Symmetric Path)**, 다른 장비를 통과하는 것을 **비대칭 경로(Asymmetric Path)**라고 부름

- 네트워크 경로 이중화를 위해 세션 장비를 두 대 이상 설치한 경우, 들어올 때와 나갈 때 **경로가 일정**해야 함

![image](https://user-images.githubusercontent.com/87461594/190892228-d947eefc-e47d-4a96-bc3c-6a54f4e588e9.png)
![image](https://user-images.githubusercontent.com/87461594/190892238-170f912a-69c4-4a43-8bf3-c8dadfe0874e.png)

<br>

### 방화벽에서 처리할 수 있는 방법

**가. 세션 테이블 동기화**

- 두 개 경로상의 두 장비가 하나의 장비처럼 동작

- 패킷 경로는 변경하지 않고 동작할 수 있지만, <u>동기화하는 시간보다 패킷 응답이 빠르면</u> 동작하지 않음

  > 애플리케이션보다 응답시간이 비교적 긴 **인터넷 게이트웨이**로 방화벽이 사용될 때 유용

![image](https://user-images.githubusercontent.com/87461594/190893478-4bbd1c9f-a896-4b00-ac21-d0e9657a9bdb.png)

**나. 세션 장비에서 보정**

- 아웃바운드 패킷을 인바운드 패킷이 통과한 세션 장비 쪽으로 보내 경로를 보정

![image](https://user-images.githubusercontent.com/87461594/190893485-06c843c0-e72c-49d0-b74a-d30c01318d4e.png)

<br>

## 6.4.3 하나의 통신에 두 개 이상의 세션이 사용될 때의 고려사항

> 특별한 목적으로 두 개 이상의 세션을 만드는 경우

- 두 세션이 <u>하나의 통신을 위해 사용하고 있다는 것</u>을 세션 장비도 파악해야 함

- **데이터 프로토콜 :** 데이터를 실어 나르는 역할
- **컨트롤 프로토콜 :** 데이터가 잘 전송되도록 세션을 제어

- 현대 프로토콜들은 대부분 컨트롤, 데이터 프로토콜 기능을 **하나의 프로토콜**에서 해결

- **FTP(File Transfer Protocol)**의 경우 컨트롤과 데이터 프로토콜이 완전히 분리되어 있음

![image](https://user-images.githubusercontent.com/87461594/190894118-4a9b2b77-8b28-440d-995c-ee6a5d795bbd.png)

<br>

### Active 모드

> 컨트롤, 데이터 프로토콜이 분리되어 있고 방향도 반대로 동작 (서버에서 클라이언트 쪽으로 데이터 푸시)

![image](https://user-images.githubusercontent.com/87461594/190894191-fb87a262-7cfc-4801-a90a-ddb260042466.png)

1. 클라이언트가 FTP 서버에 접속. 클라이언트는 1023번 이상의 TCP 포트를 사용, 서버는 TCP 21번 포트 사용
2. ① 클라이언트가 서버에 데이터를 1025번 포트를 사용해 수신하겠다고 알림
3. ② 서버는 클라이언트에 1025번 포트를 사용해 송신하겠다고 응답
4. ③ 서버에서 데이터를 보냄, 클라이언트에서 응답하고 데이터를 수신

<br>

### Passive 모드

> Active 모드와 달리 클라이언트에서 서버쪽으로 데이터를 요청해 다운받도록 동작

![image](https://user-images.githubusercontent.com/87461594/190894308-3a8aad24-65ce-43eb-9733-52acd685f098.png)

1. 클라이언트가 서버에 접속. 클라이언트는 1023번 이상의 TCP 포트를 사용, 서버는 TCP 21번 포트 사용
2. ① 클라이언트가 Passive 모드를 사용하겠다고 알림
3. ② 서버는 클라이언트에 데이터 수신에 사용할 포트를 알림. 2024번 포트를 사용해 수신하겠다고 응답
4. ③ 클라이언트에서 서버에 데이터를 요청. ② 과정에서 서버에서 알려준 2024번 포트에 요청
5. 데이터 전송