[TOC]

# 페이징과 세그먼테이션

<br>

## 가상 메모리 (Virtual Memory)

- 메모리의 공간이 **한정적**이라는 문제를 해결하기 위해 **가상 메모리 주소를 사용**하는 것
- **메모리 관리 장치 (MMU, Memory Management Unit)** 는 가상 주소를 이용해 **실제 데이터가 담겨 있는 주소로 변환**해줌 **(MAPPING)**

### [가상 메모리가 필요한 이유]

- 모든 프로그램 코드를 **물리 메모리**에 올릴 수 없고, 그렇다고 자주 교체하는 경우 **교체 성능 문제**가 발생
- 프로그램 용량이 **실제 물리 메모리보다 큰 경우**에도 실행 가능
  - **5GB 용량의 프로그램**을 **4GB 메모리**에서 실행할 수 있음
- 더 많은 프로그램을 **동시에 실행**할 수 있음

<br>

## 메모리 관리 기법

### [연속 메모리 기법]

> 프로그램 전체가 메모리에 연속적으로 할당되어야 하는 기법

- **고정 분할 기법** : 메모리가 고정된 파티션으로 분할 **(내부 단편화 발생)**
- **동적 분할 기법** : 파티션들이 동적으로 생성, 자신의 크기와 같은 파티션에 적재 **(외부 단편화 발생)**

### [불연속 메모리 기법]

> 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

- **Page** : 프로세스를 **고정된 크기의 작은 블록**들로 나눴을 때, 그 블록들
- **Frame** : 페이지 크기와 같은 **주 기억장치 메모리 블록**
- **Segment** : 서로 다른 크기의 논리적 단위

<br>

## 메모리 단편화 (Memory Fragmentation)

> 프로그램을 실행하면서 메모리 공간이 조각조각 나뉘게 되어 **실제로 사용가능한 메모리가 충분히 존재하지만 할당이 불가능**한 상태가 되는 현상

![image-20220410190100588](https://user-images.githubusercontent.com/87461594/163147561-be07fbd6-4179-4796-8029-aaa15e57318e.png)

### [내부 단편화 (Internal Fragmentation)]

> 메모리를 할당할 때 **프로세스가 필요한 양보다 더 큰 메모리가 할당**되어 프로세스의 메모리 내의 공간이 낭비되는 경우

- **30MB 의 메모리가 필요**한 프로세스에 **25MB 의 메모리가 할당**되는 경우, **5MB 만큼의 내부 단편화 발생**

### [외부 단편화 (External Fragmentation)]

> 메모리가 할당되고 해제되는 작업이 반복적으로 일어날 때, **할당된 메모리와 메모리 사이에 사용하지 않는 작은 메모리**가 생기는 경우

#### <압축>

> 프로세스가 사용하는 메모리를 한쪽으로 몰아 자유공간을 확보하는 방법론

![image-20220410193926031](https://user-images.githubusercontent.com/87461594/163147565-521964d5-2f65-45d4-851e-000f8ab0dd4f.png)

- 외부 단편화를 해소할 수 있지만, 작업효율이 좋지 않음

<br>

## 페이징 (Paging)

> 프로세스의 주소 공간을 **고정된 사이즈의 페이지 단위**로 나누어 물리적 메모리에 **불연속적으로 저장**

![img](https://user-images.githubusercontent.com/34755287/54821888-d9191700-4ce6-11e9-8b11-7af6fdbcbe06.png)

- 메모리는 `Frame` 이라는 고정 크기로 분할되고, 프로세스는 `Page` 라 불리는 고정 크기로 분할됨
- MMU 는 흩어져 있는 프로세스를 수행하기 위해 **가상 주소를 물리 주소로 변환**해주어 CPU 를 속임
  - MMU 의 재배치 레지스터를 여러 개 사용해서 실제 주소로 변경해주며, 이러한 재배치 레지스터를 **페이지 테이블 (Page Table)** 이라고 함
  - 실제 메모리는 연속적이지 않지만, **CPU 는 연속적으로 사용하고 있다는 것을 보장받으며 수행**함
- **외부 단편화**와 **압축** 작업을 해소할 수 있음
- 메모리를 **고정 크기**로 분할하기 때문에 **내부 단편화** 문제의 비중이 증가됨

<br>

## 세그먼테이션 (Segmentation)

> 프로세스를 **서로 크기가 다른 논리적인 블록 단위인 `세그먼트(Segment)` 로 분할**하고 메모리에 배치

![img](https://user-images.githubusercontent.com/34755287/57119448-47043400-6da5-11e9-95da-91cb808de992.png)

- 세그먼트를 메모리에 할당하는 것은 페이지와 동일하지만, 테이블은 페이지와 다른 **세그먼트 테이블 (Segment Table)** 활용
  - 세그먼트 테이블은 **세그먼트 번호와 시작 주소, 세그먼트 크기**를 엔트리로 가짐
- 세그먼트의 크기는 일정하지 않기 때문에, **테이블에 limit 정보**가 주어짐
  - CPU 에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 **인터럽트가 발생해서 프로세스를 종료**
- **내부 단편화**를 해결할 수 있지만, **외부 단편화** 문제가 발생할 수 있음

<br>

## [참고자료]

- https://velog.io/@nnnyeong/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98
- https://steady-coding.tistory.com/524
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/OS/README.md#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5
- https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/Paging_Segmentation.md
- https://rebro.kr/178
